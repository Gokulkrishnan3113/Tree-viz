{"ast":null,"code":"const COMPARISON = {\n  EQUAL: 0,\n  SMALLER: -1,\n  GREATER: 1\n};\nconst defaultCompareNumberFn = (a, b) => {\n  if (Number(a) === Number(b)) {\n    return COMPARISON.EQUAL;\n  }\n  return Number(a) < Number(b) ? COMPARISON.SMALLER : COMPARISON.GREATER;\n};\nclass TreeNode {\n  constructor(value, parent) {\n    this.value = value.toString();\n    this.parent = parent || null;\n    this.left = null;\n    this.right = null;\n  }\n  get isLeaf() {\n    return this.left === null && this.right === null;\n  }\n  get hasChildren() {\n    return !this.isLeaf;\n  }\n}\nclass BinarySearchTree {\n  constructor(compareFn = defaultCompareNumberFn) {\n    this.root = null;\n    this.compareFn = compareFn;\n  }\n  insert(value) {\n    let node = this.root;\n    let insertedNode;\n    if (node === null) {\n      this.root = new TreeNode(value);\n      return this.root;\n    }\n    const nodeInserted = (() => {\n      while (true) {\n        const comparison = this.compareFn(value, node.value);\n        if (comparison === COMPARISON.EQUAL) {\n          insertedNode = node;\n          return node;\n        }\n        if (comparison === COMPARISON.SMALLER) {\n          if (node.left === null) {\n            insertedNode = new TreeNode(value, node);\n            node.left = insertedNode;\n            return true;\n          }\n          node = node.left;\n        } else if (comparison === COMPARISON.GREATER) {\n          if (node.right === null) {\n            insertedNode = new TreeNode(value, node);\n            node.right = insertedNode;\n            return true;\n          }\n          node = node.right;\n        }\n      }\n    })();\n    if (nodeInserted) {\n      return insertedNode;\n    }\n  }\n  remove(value, node) {\n    node = node ? node : this.search(value);\n    if (!node) return null;\n    const isRoot = node.parent === null;\n    const isLeftChild = !isRoot ? node.parent.left === node : false;\n    if (node.left === null && node.right === null) {\n      // Case: Node is a leaf\n      if (isRoot) {\n        this.root = null;\n      } else if (isLeftChild) {\n        node.parent.left = null;\n      } else {\n        node.parent.right = null;\n      }\n      return node;\n    }\n    if (node.left === null || node.right === null) {\n      // Case: Node has one child\n      const child = node.left !== null ? node.left : node.right;\n      if (isRoot) {\n        this.root = child;\n      } else if (isLeftChild) {\n        node.parent.left = child;\n      } else {\n        node.parent.right = child;\n      }\n      if (child) {\n        child.parent = node.parent;\n      }\n      return node;\n    }\n\n    // Case: Node has both left and right children\n    const minRightLeaf = this.min(node.right);\n    // if (minRightLeaf.parent.left === minRightLeaf) {\n    //   minRightLeaf.parent.left = null;\n    // } else {\n    //   minRightLeaf.parent.right = null;\n    // }\n    const clone = {\n      ...node\n    };\n    node = minRightLeaf;\n\n    // Additional step: Update the parent's child pointer to null\n    if (minRightLeaf.parent) {\n      minRightLeaf.parent.right = null;\n    }\n    return clone;\n  }\n  search(value) {\n    return this.postOrderTraverse().find(node => node.value === value);\n  }\n  min(node) {\n    while (node.left) {\n      node = node.left;\n    }\n    return node;\n  }\n  max(node = this.root) {\n    let current = node;\n    while (current !== null && current.right !== null) {\n      current = current.right;\n    }\n    return current;\n  }\n  inOrderTraverse(node = this.root, traversed = []) {\n    if (node === null) {\n      return traversed;\n    }\n    if (node.left) {\n      traversed.push(...this.inOrderTraverse(node.left));\n    }\n    traversed.push(node);\n    if (node.right) {\n      traversed.push(...this.inOrderTraverse(node.right));\n    }\n    return traversed;\n  }\n  preOrderTraverse(node = this.root, traversed = []) {\n    if (node === null) {\n      return traversed;\n    }\n    traversed.push(node);\n    if (node.left) {\n      traversed.push(...this.preOrderTraverse(node.left));\n    }\n    if (node.right) {\n      traversed.push(...this.preOrderTraverse(node.right));\n    }\n    return traversed;\n  }\n  postOrderTraverse(node = this.root, traversed = []) {\n    if (node === null) {\n      return traversed;\n    }\n    if (node.left) {\n      traversed.push(...this.postOrderTraverse(node.left));\n    }\n    if (node.right) {\n      traversed.push(...this.postOrderTraverse(node.right));\n    }\n    traversed.push(node);\n    return traversed;\n  }\n}\nexport default BinarySearchTree;","map":{"version":3,"names":["COMPARISON","EQUAL","SMALLER","GREATER","defaultCompareNumberFn","a","b","Number","TreeNode","constructor","value","parent","toString","left","right","isLeaf","hasChildren","BinarySearchTree","compareFn","root","insert","node","insertedNode","nodeInserted","comparison","remove","search","isRoot","isLeftChild","child","minRightLeaf","min","clone","postOrderTraverse","find","max","current","inOrderTraverse","traversed","push","preOrderTraverse"],"sources":["/Users/gokulkrishnan/College/project/treeviz/src/BST/js_binary_search_tree.js"],"sourcesContent":["const COMPARISON = {\r\n  EQUAL: 0,\r\n  SMALLER: -1,\r\n  GREATER: 1,\r\n};\r\n\r\nconst defaultCompareNumberFn = (a, b) => {\r\n  if (Number(a) === Number(b)) {\r\n    return COMPARISON.EQUAL;\r\n  }\r\n\r\n  return Number(a) < Number(b) ? COMPARISON.SMALLER : COMPARISON.GREATER;\r\n};\r\n\r\nclass TreeNode {\r\n  constructor(value, parent) {\r\n    this.value = value.toString();\r\n    this.parent = parent || null;\r\n    this.left = null;\r\n    this.right = null;\r\n  }\r\n\r\n  get isLeaf() {\r\n    return this.left === null && this.right === null;\r\n  }\r\n\r\n  get hasChildren() {\r\n    return !this.isLeaf;\r\n  }\r\n}\r\nclass BinarySearchTree {\r\n  root;\r\n  compareFn;\r\n  constructor(compareFn = defaultCompareNumberFn) {\r\n    this.root = null;\r\n    this.compareFn = compareFn;\r\n  }\r\n\r\n  insert(value) {\r\n    let node = this.root;\r\n    let insertedNode;\r\n    if (node === null) {\r\n      this.root = new TreeNode(value);\r\n      return this.root;\r\n    }\r\n    const nodeInserted = (() => {\r\n      while (true) {\r\n        const comparison = this.compareFn(value, node.value);\r\n        if (comparison === COMPARISON.EQUAL) {\r\n          insertedNode = node;\r\n          return node;\r\n        }\r\n        if (comparison === COMPARISON.SMALLER) {\r\n          if (node.left === null) {\r\n            insertedNode = new TreeNode(value, node);\r\n            node.left = insertedNode;\r\n            return true;\r\n          }\r\n          node = node.left;\r\n        } else if (comparison === COMPARISON.GREATER) {\r\n          if (node.right === null) {\r\n            insertedNode = new TreeNode(value, node);\r\n            node.right = insertedNode;\r\n            return true;\r\n          }\r\n          node = node.right;\r\n        }\r\n      }\r\n    })();\r\n    if (nodeInserted) {\r\n      return insertedNode;\r\n    }\r\n  }\r\n\r\n  remove(value, node) {\r\n    node = node ? node : this.search(value);\r\n    if (!node) return null;\r\n  \r\n    const isRoot = node.parent === null;\r\n    const isLeftChild = !isRoot ? node.parent.left === node : false;\r\n  \r\n    if (node.left === null && node.right === null) {\r\n      // Case: Node is a leaf\r\n      if (isRoot) {\r\n        this.root = null;\r\n      } else if (isLeftChild) {\r\n        node.parent.left = null;\r\n      } else {\r\n        node.parent.right = null;\r\n      }\r\n      return node;\r\n    }\r\n  \r\n    if (node.left === null || node.right === null) {\r\n      // Case: Node has one child\r\n      const child = node.left !== null ? node.left : node.right;\r\n      if (isRoot) {\r\n        this.root = child;\r\n      } else if (isLeftChild) {\r\n        node.parent.left = child;\r\n      } else {\r\n        node.parent.right = child;\r\n      }\r\n      if (child) {\r\n        child.parent = node.parent;\r\n      }\r\n      return node;\r\n    }\r\n  \r\n    // Case: Node has both left and right children\r\n    const minRightLeaf = this.min(node.right);\r\n    // if (minRightLeaf.parent.left === minRightLeaf) {\r\n    //   minRightLeaf.parent.left = null;\r\n    // } else {\r\n    //   minRightLeaf.parent.right = null;\r\n    // }\r\n    const clone = { ...node };\r\n    node = minRightLeaf;\r\n  \r\n    // Additional step: Update the parent's child pointer to null\r\n    if (minRightLeaf.parent) {\r\n      minRightLeaf.parent.right = null;\r\n    }\r\n  \r\n    return clone;\r\n  }\r\n  \r\n  \r\n  search(value) {\r\n    return this.postOrderTraverse().find((node) => node.value === value);\r\n  }\r\n  \r\n  \r\n  min(node) {\r\n    while (node.left) {\r\n      node = node.left;\r\n    }\r\n    return node;\r\n  }\r\n  max(node = this.root) {\r\n    let current = node;\r\n    while (current !== null && current.right !== null) {\r\n      current = current.right;\r\n    }\r\n    return current;\r\n  }\r\n  inOrderTraverse(node = this.root, traversed = []) {\r\n    if (node === null) {\r\n      return traversed;\r\n    }\r\n    if (node.left) {\r\n      traversed.push(...this.inOrderTraverse(node.left));\r\n    }\r\n    traversed.push(node);\r\n    if (node.right) {\r\n      traversed.push(...this.inOrderTraverse(node.right));\r\n    }\r\n    return traversed;\r\n  }\r\n  \r\n  preOrderTraverse(node = this.root, traversed = []) {\r\n    if (node === null) {\r\n      return traversed;\r\n    }\r\n    traversed.push(node);\r\n    if (node.left) {\r\n      traversed.push(...this.preOrderTraverse(node.left));\r\n    }\r\n    if (node.right) {\r\n      traversed.push(...this.preOrderTraverse(node.right));\r\n    }\r\n    return traversed;\r\n  }\r\n  \r\n  postOrderTraverse(node = this.root, traversed = []) {\r\n    if (node === null) {\r\n      return traversed;\r\n    }\r\n    if (node.left) {\r\n      traversed.push(...this.postOrderTraverse(node.left));\r\n    }\r\n    if (node.right) {\r\n      traversed.push(...this.postOrderTraverse(node.right));\r\n    }\r\n    traversed.push(node);\r\n    return traversed;\r\n  }\r\n}  \r\n\r\nexport default BinarySearchTree;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
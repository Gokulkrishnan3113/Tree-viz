{"ast":null,"code":"import BinarySearchTree from \"../BST/js_binary_search_tree\";\nconst COLOR = Object.freeze({\n  RED: 'red',\n  BLACK: 'black'\n});\nclass RedBlackNode {\n  constructor(key = null, parent = null) {\n    this.left = null;\n    this.right = null;\n    this.key = key;\n    this.parent = parent;\n    if (key == null) {\n      this.color = COLOR.BLACK;\n    } else {\n      this.color = COLOR.RED;\n      this.left = new RedBlackNode(null, this);\n      this.right = new RedBlackNode(null, this);\n    }\n  }\n  get isRed() {\n    return this.color === COLOR.RED;\n  }\n  get isBlack() {\n    return !this.isRed;\n  }\n  get isNil() {\n    return this.key === null;\n  }\n  get color() {\n    return this.color;\n  }\n  set color(newColor) {\n    if (!this.isNil) {\n      this.color = newColor;\n    }\n  }\n}\nclass RBTREE extends BinarySearchTree {\n  constructor(compareFn = null) {\n    let fn = null;\n    if (compareFn && typeof compareFn === 'function') {\n      fn = compareFn;\n    } else {\n      fn = (a, b) => {\n        if (a > b) return BinarySearchTree.defaultCompareNumberFn.BIGGER;\n        if (a < b) return BinarySearchTree.defaultCompareNumberFn.SMALLER;\n        return BinarySearchTree.defaultCompareNumberFn.EQUAL;\n      };\n    }\n    super(fn);\n    this.root = null;\n    this.insertNode = (newNode, currentNode = this.root) => {\n      if (this.compare(newNode.key, currentNode.key) === BinarySearchTree.comparison.SMALLER) {\n        if (currentNode.left.isNil) {\n          currentNode.left = newNode;\n          newNode.parent = currentNode;\n        } else {\n          this.insertNode(newNode, currentNode.left);\n        }\n      } else {\n        if (currentNode.right.isNil) {\n          currentNode.right = newNode;\n          newNode.parent = currentNode;\n        } else {\n          this.insertNode(newNode, currentNode.right);\n        }\n      }\n    };\n    this.RRotation = node => {\n      if (node.left) {\n        // console.log('r rotate', node.key);\n        const nodeParent = node.parent;\n        const detached = node.left;\n        node.left = detached.right;\n        detached.right = node;\n        node.parent = detached;\n        if (node.left !== null) {\n          node.left.parent = node;\n        }\n        if (nodeParent !== null) {\n          if (node === nodeParent.left) {\n            nodeParent.left = detached;\n          } else {\n            nodeParent.right = detached;\n          }\n        } else {\n          this.root = detached;\n        }\n        detached.parent = nodeParent;\n      }\n    };\n    this.LRotation = node => {\n      if (node.right) {\n        // console.log('l rotate', node.key);\n        const nodeParent = node.parent;\n        const detached = node.right;\n        node.right = detached.left;\n        detached.left = node;\n        node.parent = detached;\n        if (node.right !== null) {\n          node.right.parent = node;\n        }\n        if (nodeParent !== null) {\n          if (node === nodeParent.left) {\n            nodeParent.left = detached;\n          } else {\n            nodeParent.right = detached;\n          }\n        } else {\n          this.root = detached;\n        }\n        detached.parent = nodeParent;\n      }\n    };\n    this.removeNode = (key, node = this.root) => {\n      if (node === null || node.isNil) return;\n      if (this.compare(key, node.key) === BinarySearchTree.comparison.SMALLER) {\n        this.removeNode(key, node.left);\n      } else if (this.compare(key, node.key) === BinarySearchTree.comparison.BIGGER) {\n        this.removeNode(key, node.right);\n      } else if (node.left.isNil && node.right.isNil) {\n        // console.log('remove 1', node.key)\n        this.handleRemovedNode(node);\n        if (node.parent === null) {\n          this.root = null;\n        } else if (node === node.parent.left) {\n          node.parent.left = this.createNode(null, node);\n        } else {\n          node.parent.right = this.createNode(null, node);\n        }\n      } else if (node.left.isNil) {\n        // console.log('remove 2', node.key)\n        node.key = node.right.key;\n        node.right = this.createNode(null, node);\n      } else if (node.right.isNil) {\n        // console.log('remove 3', node.key)\n        node.key = node.left.key;\n        node.left = this.createNode(null, node);\n      } else {\n        const max = this.maxNode(node.left);\n        // console.log('remove 4', node.key)\n        node.key = max.key;\n        this.removeNode(max.key, node.left);\n      }\n    };\n    this.maxNode = node => {\n      while (node && !node.isNill && !node.right.isNil) {\n        node = node.right;\n      }\n      return node;\n    };\n    this.compare = fn;\n  }\n  get root() {\n    return this.root;\n  }\n  createNode(key = null, parent = null) {\n    return new RedBlackNode(key, parent);\n  }\n  insertrb(key) {\n    const newNode = this.createNode(key);\n    if (this.root === null) {\n      this.root = newNode;\n    } else {\n      this.insertNode(newNode);\n    }\n    this.adjustTreeAfterInsertion(newNode);\n  }\n  adjustTreeAfterInsertion(node) {\n    if (node.parent === null) {\n      node.color = COLOR.BLACK;\n    } else if (node.parent.isRed) {\n      const parentNode = node.parent;\n      const grandParentNode = parentNode.parent;\n      const uncleNode = grandParentNode.left === parentNode ? grandParentNode.right : grandParentNode.left;\n      if (uncleNode.isBlack) {\n        // console.log('red parent blk uncle')\n        this.handleBlackUncle(node);\n      } else {\n        // console.log('red parent red uncle')\n        this.handleRedUncle(parentNode, uncleNode, grandParentNode);\n      }\n    }\n  }\n  handleBlackUncle(node) {\n    const parentNode = node.parent;\n    if (node === parentNode.left) {\n      if (parentNode === parentNode.parent.left) {\n        this.recolorMidNode(parentNode);\n        this.RRotation(parentNode.parent);\n      } else {\n        this.RRotation(parentNode);\n        this.recolorMidNode(node);\n        this.LRotation(node.parent);\n      }\n    } else {\n      if (parentNode === parentNode.parent.right) {\n        this.recolorMidNode(parentNode);\n        this.LRotation(parentNode.parent);\n      } else {\n        this.LRotation(parentNode);\n        this.recolorMidNode(node);\n        this.RRotation(node.parent);\n      }\n    }\n  }\n  handleRedUncle(parentNode, uncleNode, grandParentNode) {\n    parentNode.color = COLOR.BLACK;\n    uncleNode.color = COLOR.BLACK;\n    grandParentNode.color = COLOR.RED;\n    this.adjustTreeAfterInsertion(grandParentNode);\n  }\n  recolorMidNode(node) {\n    node.color = COLOR.BLACK;\n    node.parent.color = COLOR.RED;\n  }\n  removerb(key) {\n    this.removeNode(key);\n  }\n  getNodeSibling(node) {\n    const parentNode = node.parent;\n    const sibNode = parentNode.left === node ? parentNode.right : parentNode.left;\n    return sibNode;\n  }\n  handleCase2(node) {\n    // sibling is red with 2 black children\n    const sibNode = this.getNodeSibling(node);\n    if (sibNode.isRed) {\n      const parentNode = node.parent;\n      sibNode.color = COLOR.BLACK;\n      parentNode.color = COLOR.RED;\n      if (node === parentNode.left) {\n        this.LRotation(parentNode);\n      } else {\n        this.RRotation(parentNode);\n      }\n    }\n    this.handleCase3(node);\n  }\n  handleCase3(node) {\n    // node parent is black, sibling and its children are black\n    const sibNode = this.getNodeSibling(node);\n    if (node.parent.isBlack && sibNode.isBlack && sibNode.left.isBlack && sibNode.right.isBlack) {\n      sibNode.color = COLOR.RED;\n      this.handleRemovedNode(node.parent);\n    } else {\n      this.handleCase4(node);\n    }\n  }\n  handleCase4(node) {\n    // node parent is red, sibling and its children are black\n    const sibNode = this.getNodeSibling(node);\n    if (node.parent.isRed && sibNode.isBlack && sibNode.left.isBlack && sibNode.right.isBlack) {\n      sibNode.color = COLOR.RED;\n      node.parent.color = COLOR.BLACK;\n    } else {\n      this.handleCase5(node);\n    }\n  }\n  handleCase5(node) {\n    // sib is black with red left and black right\n    const sibNode = this.getNodeSibling(node);\n    if (sibNode.isBlack) {\n      const parentNode = node.parent;\n      if (node === parentNode.left && sibNode.left.isRed && sibNode.right.isBlack) {\n        sibNode.color = COLOR.RED;\n        sibNode.left.color = COLOR.BLACK;\n        this.RRotation(sibNode);\n      }\n      if (node === parentNode.right && sibNode.left.isBlack && sibNode.right.isRed) {\n        sibNode.color = COLOR.RED;\n        sibNode.right.color = COLOR.BLACK;\n        this.LRotation(sibNode);\n      }\n    }\n    this.handleCase6(node);\n  }\n  handleCase6(node) {\n    // sib is black with red right and black left\n    const sibNode = this.getNodeSibling(node);\n    const parentNode = node.parent;\n    sibNode.color = parentNode.color;\n    parentNode.color = COLOR.BLACK;\n    if (node === parentNode.left) {\n      sibNode.right.color = COLOR.BLACK;\n      this.LRotation(parentNode);\n    } else {\n      sibNode.left.color = COLOR.BLACK;\n      this.RRotation(parentNode);\n    }\n  }\n  handleRemovedNode(node) {\n    // console.log('case 1', node.key);\n    // node is black and with a parent\n    if (node.isBlack && node.parent !== null) {\n      // case 1\n      this.handleCase2(node);\n    }\n  }\n}\nexport default RBTREE;","map":{"version":3,"names":["BinarySearchTree","COLOR","Object","freeze","RED","BLACK","RedBlackNode","constructor","key","parent","left","right","color","isRed","isBlack","isNil","newColor","RBTREE","compareFn","fn","a","b","defaultCompareNumberFn","BIGGER","SMALLER","EQUAL","root","insertNode","newNode","currentNode","compare","comparison","RRotation","node","nodeParent","detached","LRotation","removeNode","handleRemovedNode","createNode","max","maxNode","isNill","insertrb","adjustTreeAfterInsertion","parentNode","grandParentNode","uncleNode","handleBlackUncle","handleRedUncle","recolorMidNode","removerb","getNodeSibling","sibNode","handleCase2","handleCase3","handleCase4","handleCase5","handleCase6"],"sources":["/Users/gokulkrishnan/College/project/treeviz/src/RB/rb.js"],"sourcesContent":["import BinarySearchTree from \"../BST/js_binary_search_tree\";\nconst COLOR = Object.freeze({\n    RED: 'red',\n    BLACK: 'black'\n  })\n\n  class RedBlackNode {\n    color;\n    left = null;\n    right = null;\n    constructor(key = null, parent = null) {\n        this.key = key;\n        this.parent = parent;\n        \n        if(key == null) {\n          this.color = COLOR.BLACK;\n        } else {\n          this.color = COLOR.RED;\n          this.left = new RedBlackNode(null, this);\n          this.right = new RedBlackNode(null, this);\n        }\n      }\n      get isRed() {\n        return this.color === COLOR.RED;\n      }\n      \n      get isBlack() {\n        return !this.isRed\n      }\n      \n      get isNil() {\n        return this.key === null;\n      }\n      \n      get color() {\n        return this.color;\n      }\n      \n      set color(newColor) {\n        if(!this.isNil) {\n           this.color = newColor;\n        }\n      }\n    \n  }\n\n  class RBTREE extends BinarySearchTree{\n    root = null;\n    compare;\n    \n    constructor(compareFn = null) {\n      let fn = null;\n      \n      if(compareFn && typeof compareFn === 'function') {\n        fn = compareFn;\n      } else {\n        fn = (a, b) => {\n          if(a > b) return BinarySearchTree.defaultCompareNumberFn.BIGGER;\n          if(a < b) return BinarySearchTree.defaultCompareNumberFn.SMALLER;\n        \n          return BinarySearchTree.defaultCompareNumberFn.EQUAL;\n        }\n      }\n  \n      super(fn);\n      this.compare = fn;\n    }\n    get root() {\n        return this.root;\n      }\n      \n      createNode(key = null, parent = null) {\n        return new RedBlackNode(key, parent);\n      }\n      \n      insertrb(key) {\n        const newNode = this.createNode(key);\n        \n        if(this.root === null) {\n          this.root = newNode;\n        } else {\n          this.insertNode(newNode);\n        }\n        \n        this.adjustTreeAfterInsertion(newNode);\n      }\n\n      insertNode = (newNode, currentNode = this.root) => {\n        if(this.compare(newNode.key, currentNode.key) === BinarySearchTree.comparison.SMALLER) {\n           if(currentNode.left.isNil) {\n             currentNode.left = newNode;\n             newNode.parent = currentNode;\n           } else {\n            this.insertNode(newNode, currentNode.left)\n          }                            \n        } else {\n           if(currentNode.right.isNil) {\n             currentNode.right = newNode;\n             newNode.parent = currentNode;\n           } else {\n             this.insertNode(newNode, currentNode.right)\n           }  \n        }\n      }\n\n      adjustTreeAfterInsertion(node) {\n        if(node.parent === null) {\n          node.color = COLOR.BLACK;\n        } else if(node.parent.isRed) {\n          const parentNode = node.parent;\n          const grandParentNode = parentNode.parent;\n          const uncleNode = grandParentNode.left === parentNode\n            ? grandParentNode.right\n            : grandParentNode.left;\n          \n          if(uncleNode.isBlack) {\n            // console.log('red parent blk uncle')\n            this.handleBlackUncle(node);\n          } else {\n            // console.log('red parent red uncle')\n            this.handleRedUncle(parentNode, uncleNode, grandParentNode)\n          }\n        }\n      }\n\n      handleBlackUncle(node) {\n        const parentNode = node.parent;\n        \n        if(node === parentNode.left) {\n          if(parentNode === parentNode.parent.left) {\n            this.recolorMidNode(parentNode);\n            this.RRotation(parentNode.parent);\n          } else {\n            this.RRotation(parentNode);\n            this.recolorMidNode(node);\n            this.LRotation(node.parent);\n          }\n        } else {\n          if(parentNode === parentNode.parent.right) {\n            this.recolorMidNode(parentNode);\n            this.LRotation(parentNode.parent);\n          } else {\n            this.LRotation(parentNode);\n            this.recolorMidNode(node);\n            this.RRotation(node.parent);\n          }\n        }\n      }\n\n      RRotation = (node) => {\n        if(node.left) {\n          // console.log('r rotate', node.key);\n          const nodeParent = node.parent;\n          const detached = node.left;\n          node.left = detached.right;\n          detached.right = node;\n          node.parent = detached;\n          \n          if(node.left !== null) {\n            node.left.parent = node;\n          }\n          \n          if(nodeParent !== null) {\n            if(node === nodeParent.left) {\n              nodeParent.left = detached;\n            } else {\n              nodeParent.right = detached;\n            }\n          } else {\n            this.root = detached;\n          }\n          \n          detached.parent = nodeParent;\n        }\n      }\n      \n      LRotation = (node) => {\n        if(node.right) {\n          // console.log('l rotate', node.key);\n          const nodeParent = node.parent;\n          const detached = node.right;\n          node.right = detached.left;\n          detached.left = node;\n          node.parent = detached;\n          \n          if(node.right !== null) {\n            node.right.parent = node;\n          }\n          \n          if(nodeParent !== null) {\n            if(node === nodeParent.left) {\n              nodeParent.left = detached;\n            } else {\n              nodeParent.right = detached;\n            }\n          } else {\n            this.root = detached;\n          }\n          \n          detached.parent = nodeParent;\n        }\n      }\n\n\n      handleRedUncle(parentNode, uncleNode, grandParentNode) {\n        parentNode.color = COLOR.BLACK;\n        uncleNode.color = COLOR.BLACK;\n        grandParentNode.color = COLOR.RED;\n        this.adjustTreeAfterInsertion(grandParentNode);\n      }\n\n      recolorMidNode(node) {\n        node.color = COLOR.BLACK;\n        node.parent.color = COLOR.RED;\n      }\n\n\n\n\n      removerb(key) {\n        this.removeNode(key);\n      }\n\n      removeNode = (key, node = this.root) => {\n        if(node === null || node.isNil) return;\n    \n        if(this.compare(key, node.key) === BinarySearchTree.comparison.SMALLER) {\n          this.removeNode(key, node.left);\n        } else if(this.compare(key, node.key) === BinarySearchTree.comparison.BIGGER) {\n          this.removeNode(key, node.right);\n        } else if(node.left.isNil && node.right.isNil) {\n          // console.log('remove 1', node.key)\n          this.handleRemovedNode(node);\n          \n          if(node.parent === null) {\n            this.root = null;\n          } else if(node === node.parent.left) {\n            node.parent.left = this.createNode(null, node);\n          } else {\n            node.parent.right = this.createNode(null, node);\n          }\n        } else if(node.left.isNil) {\n          // console.log('remove 2', node.key)\n          node.key = node.right.key;\n          node.right = this.createNode(null, node);\n        } else if(node.right.isNil) {\n          // console.log('remove 3', node.key)\n          node.key = node.left.key;\n          node.left = this.createNode(null, node);\n        } else {\n          const max = this.maxNode(node.left);\n          // console.log('remove 4', node.key)\n          node.key = max.key;\n          this.removeNode(max.key, node.left);\n        }\n      }\n      maxNode = (node) => {\n        while(node && !node.isNill && !node.right.isNil) {\n          node = node.right;\n        }\n    \n        return node;\n      }\n\n      getNodeSibling(node) {\n        const parentNode = node.parent;\n        const sibNode = parentNode.left === node\n          ? parentNode.right\n          : parentNode.left;\n        \n        return sibNode;\n      }\n\n      handleCase2(node) {\n        // sibling is red with 2 black children\n        const sibNode = this.getNodeSibling(node);\n    \n        if(sibNode.isRed) {\n          const parentNode = node.parent;\n        \n          sibNode.color = COLOR.BLACK;\n          parentNode.color = COLOR.RED;\n    \n          if(node === parentNode.left) {\n            this.LRotation(parentNode);\n          } else {\n            this.RRotation(parentNode);\n          }\n        }\n        \n        this.handleCase3(node);\n      }\n      \n      handleCase3(node) {\n        // node parent is black, sibling and its children are black\n        const sibNode = this.getNodeSibling(node);\n        \n        if(\n          node.parent.isBlack && \n          sibNode.isBlack && \n          sibNode.left.isBlack && \n          sibNode.right.isBlack\n        ) {\n          sibNode.color = COLOR.RED;\n          this.handleRemovedNode(node.parent);\n        } else {\n          this.handleCase4(node);\n        }\n      }\n      \n      handleCase4(node) {\n        // node parent is red, sibling and its children are black\n        const sibNode = this.getNodeSibling(node);\n        \n        if(\n          node.parent.isRed && \n          sibNode.isBlack && \n          sibNode.left.isBlack && \n          sibNode.right.isBlack\n        ) {\n          sibNode.color = COLOR.RED;\n          node.parent.color = COLOR.BLACK;\n        } else {\n          this.handleCase5(node);\n        }\n      }\n      \n      handleCase5(node) {\n        // sib is black with red left and black right\n        const sibNode = this.getNodeSibling(node);\n        \n        if(sibNode.isBlack) {\n          const parentNode = node.parent;\n        \n          if(node === parentNode.left && sibNode.left.isRed && sibNode.right.isBlack) {\n            sibNode.color = COLOR.RED;\n            sibNode.left.color = COLOR.BLACK;\n            this.RRotation(sibNode);\n          }\n    \n          if(node === parentNode.right && sibNode.left.isBlack && sibNode.right.isRed) {\n            sibNode.color = COLOR.RED;\n            sibNode.right.color = COLOR.BLACK;\n            this.LRotation(sibNode);\n          }\n        }\n       \n        this.handleCase6(node);\n      }\n      \n      handleCase6(node) {\n        // sib is black with red right and black left\n        const sibNode = this.getNodeSibling(node);\n        const parentNode = node.parent;\n          \n        sibNode.color = parentNode.color;\n        parentNode.color = COLOR.BLACK;\n    \n        if(node === parentNode.left) {\n          sibNode.right.color = COLOR.BLACK;\n          this.LRotation(parentNode);\n        } else {\n          sibNode.left.color = COLOR.BLACK;\n          this.RRotation(parentNode);\n        }\n      }\n      \n      handleRemovedNode(node) {\n        // console.log('case 1', node.key);\n        // node is black and with a parent\n        if(node.isBlack && node.parent !== null) {// case 1\n          this.handleCase2(node);\n        }\n      }\n      \n\n  }\nexport default RBTREE;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
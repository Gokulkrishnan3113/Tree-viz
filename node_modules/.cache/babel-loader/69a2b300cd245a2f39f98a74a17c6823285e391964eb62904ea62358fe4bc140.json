{"ast":null,"code":"const COMPARISON = {\n  EQUAL: 0,\n  SMALLER: -1,\n  GREATER: 1\n};\nconst defaultCompareNumberFn = (a, b) => {\n  if (Number(a) === Number(b)) {\n    return COMPARISON.EQUAL;\n  }\n  return Number(a) < Number(b) ? COMPARISON.SMALLER : COMPARISON.GREATER;\n};\nclass TreeNode {\n  constructor(value, parent) {\n    this.value = value.toString();\n    this.parent = parent || null;\n    this.left = null;\n    this.right = null;\n  }\n  get isLeaf() {\n    return this.left === null && this.right === null;\n  }\n  get hasChildren() {\n    return !this.isLeaf;\n  }\n}\nclass BinarySearchTree {\n  constructor(compareFn = defaultCompareNumberFn) {\n    this.root = null;\n    this.compareFn = compareFn;\n  }\n  get root() {\n    return this.root;\n  }\n  set root(newRoot) {\n    this.root = newRoot;\n  }\n  insert(value) {\n    let node = this.root;\n    let insertedNode;\n    if (node === null) {\n      this.root = new TreeNode(value);\n      return this.root;\n    }\n    const nodeInserted = (() => {\n      while (true) {\n        const comparison = this.compareFn(value, node.value);\n        if (comparison === COMPARISON.EQUAL) {\n          insertedNode = node;\n          return node;\n        }\n        if (comparison === COMPARISON.SMALLER) {\n          if (node.left === null) {\n            insertedNode = new TreeNode(value, node);\n            node.left = insertedNode;\n            return true;\n          }\n          node = node.left;\n        } else if (comparison === COMPARISON.GREATER) {\n          if (node.right === null) {\n            insertedNode = new TreeNode(value, node);\n            node.right = insertedNode;\n            return true;\n          }\n          node = node.right;\n        }\n      }\n    })();\n    if (nodeInserted) {\n      return insertedNode;\n    }\n  }\n  remove(value, node) {\n    console.log(\"superremove\");\n    node = node ? node : this.search(value);\n    if (!node) return null;\n    const isRoot = node.parent === null;\n    const isLeftChild = !isRoot ? node.parent.left === node : false;\n    if (node.left === null && node.right === null) {\n      // Case: Node is a leaf\n      if (isRoot) {\n        this.root = null;\n      } else if (isLeftChild) {\n        node.parent.left = null;\n      } else {\n        node.parent.right = null;\n      }\n      return node;\n    }\n    if (node.left === null || node.right === null) {\n      // Case: Node has one child\n      const child = node.left !== null ? node.left : node.right;\n      if (isRoot) {\n        this.root = child;\n      } else if (isLeftChild) {\n        node.parent.left = child;\n      } else {\n        node.parent.right = child;\n      }\n      if (child) {\n        child.parent = node.parent;\n      }\n      return node;\n    }\n\n    // Case: Node has both left and right children\n    console.log(\"passvalue\" + node.right.value);\n    const minRightLeaf = this.min(node.right);\n    console.log(\"leftmin\" + minRightLeaf.value);\n    // if (minRightLeaf.parent.left === minRightLeaf) {\n    //   minRightLeaf.parent.left = null;\n    // } else {\n    //   minRightLeaf.parent.right = null;\n    // }\n    const clone = {\n      ...node\n    };\n    node.value = minRightLeaf.value;\n    this.remove(minRightLeaf.value);\n    // Additional step: Update the parent's child pointer to null\n    // if (minRightLeaf.parent) {\n    //   minRightLeaf.parent.right = null;\n    // }\n\n    return clone;\n  }\n  search(value) {\n    return this.postOrderTraverse().find(node => node.value === value);\n  }\n  min(node) {\n    while (node.left !== null) {\n      node = node.left;\n    }\n    return node;\n  }\n  minimum(node = this.root) {\n    let current = node;\n    while (current !== null && current.left !== null) {\n      current = current.left;\n    }\n    return current;\n  }\n  max(node = this.root) {\n    let current = node;\n    while (current !== null && current.right !== null) {\n      current = current.right;\n    }\n    return current;\n  }\n  inOrderTraverse(node = this.root, traversed = []) {\n    if (node === null) {\n      return traversed;\n    }\n    if (node.left) {\n      traversed.push(...this.inOrderTraverse(node.left));\n    }\n    traversed.push(node);\n    if (node.right) {\n      traversed.push(...this.inOrderTraverse(node.right));\n    }\n    return traversed;\n  }\n  preOrderTraverse(node = this.root, traversed = []) {\n    if (node === null) {\n      return traversed;\n    }\n    traversed.push(node);\n    if (node.left) {\n      traversed.push(...this.preOrderTraverse(node.left));\n    }\n    if (node.right) {\n      traversed.push(...this.preOrderTraverse(node.right));\n    }\n    return traversed;\n  }\n  postOrderTraverse(node = this.root, traversed = []) {\n    if (node === null) {\n      return traversed;\n    }\n    if (node.left) {\n      traversed.push(...this.postOrderTraverse(node.left));\n    }\n    if (node.right) {\n      traversed.push(...this.postOrderTraverse(node.right));\n    }\n    traversed.push(node);\n    return traversed;\n  }\n}\nexport default BinarySearchTree;","map":{"version":3,"names":["COMPARISON","EQUAL","SMALLER","GREATER","defaultCompareNumberFn","a","b","Number","TreeNode","constructor","value","parent","toString","left","right","isLeaf","hasChildren","BinarySearchTree","compareFn","root","newRoot","insert","node","insertedNode","nodeInserted","comparison","remove","console","log","search","isRoot","isLeftChild","child","minRightLeaf","min","clone","postOrderTraverse","find","minimum","current","max","inOrderTraverse","traversed","push","preOrderTraverse"],"sources":["/Users/gokulkrishnan/College/project/treeviz/src/BST/js_binary_search_tree.js"],"sourcesContent":["const COMPARISON = {\r\n  EQUAL: 0,\r\n  SMALLER: -1,\r\n  GREATER: 1,\r\n};\r\n\r\nconst defaultCompareNumberFn = (a, b) => {\r\n  if (Number(a) === Number(b)) {\r\n    return COMPARISON.EQUAL;\r\n  }\r\n\r\n  return Number(a) < Number(b) ? COMPARISON.SMALLER : COMPARISON.GREATER;\r\n};\r\n\r\nclass TreeNode {\r\n  constructor(value, parent) {\r\n    this.value = value.toString();\r\n    this.parent = parent || null;\r\n    this.left = null;\r\n    this.right = null;\r\n  }\r\n\r\n  get isLeaf() {\r\n    return this.left === null && this.right === null;\r\n  }\r\n\r\n  get hasChildren() {\r\n    return !this.isLeaf;\r\n  }\r\n}\r\nclass BinarySearchTree {\r\n  root;\r\n  compareFn;\r\n\r\n  constructor(compareFn = defaultCompareNumberFn) {\r\n    this.root = null;\r\n    this.compareFn = compareFn;\r\n  }\r\n\r\n  get root() {\r\n    return this.root;\r\n  }\r\n\r\n  set root(newRoot) {\r\n    this.root = newRoot;\r\n  }\r\n\r\n  insert(value) {\r\n    let node = this.root;\r\n    let insertedNode;\r\n    if (node === null) {\r\n      this.root = new TreeNode(value);\r\n      return this.root;\r\n    }\r\n    const nodeInserted = (() => {\r\n      while (true) {\r\n        const comparison = this.compareFn(value, node.value);\r\n        if (comparison === COMPARISON.EQUAL) {\r\n          insertedNode = node;\r\n          return node;\r\n        }\r\n        if (comparison === COMPARISON.SMALLER) {\r\n          if (node.left === null) {\r\n            insertedNode = new TreeNode(value, node);\r\n            node.left = insertedNode;\r\n            return true;\r\n          }\r\n          node = node.left;\r\n        } else if (comparison === COMPARISON.GREATER) {\r\n          if (node.right === null) {\r\n            insertedNode = new TreeNode(value, node);\r\n            node.right = insertedNode;\r\n            return true;\r\n          }\r\n          node = node.right;\r\n        }\r\n      }\r\n    })();\r\n    if (nodeInserted) {\r\n      return insertedNode;\r\n    }\r\n  }\r\n\r\n  remove(value, node) {\r\n    console.log(\"superremove\");\r\n    node = node ? node : this.search(value);\r\n    if (!node) return null;\r\n  \r\n    const isRoot = node.parent === null;\r\n    const isLeftChild = !isRoot ? node.parent.left === node : false;\r\n  \r\n    if (node.left === null && node.right === null) {\r\n      // Case: Node is a leaf\r\n      if (isRoot) {\r\n        this.root = null;\r\n      } else if (isLeftChild) {\r\n        node.parent.left = null;\r\n      } else {\r\n        node.parent.right = null;\r\n      }\r\n      return node;\r\n    }\r\n  \r\n    if (node.left === null || node.right === null) {\r\n      // Case: Node has one child\r\n      const child = node.left !== null ? node.left : node.right;\r\n      if (isRoot) {\r\n        this.root = child;\r\n      } else if (isLeftChild) {\r\n        node.parent.left = child;\r\n      } else {\r\n        node.parent.right = child;\r\n      }\r\n      if (child) {\r\n        child.parent = node.parent;\r\n      }\r\n      return node;\r\n    }\r\n  \r\n    // Case: Node has both left and right children\r\n    console.log(\"passvalue\"+node.right.value);\r\n    const minRightLeaf = this.min(node.right);\r\n    console.log(\"leftmin\"+minRightLeaf.value);\r\n    // if (minRightLeaf.parent.left === minRightLeaf) {\r\n    //   minRightLeaf.parent.left = null;\r\n    // } else {\r\n    //   minRightLeaf.parent.right = null;\r\n    // }\r\n    const clone = { ...node };\r\n    node.value = minRightLeaf.value;\r\n    this.remove(minRightLeaf.value);\r\n    // Additional step: Update the parent's child pointer to null\r\n    // if (minRightLeaf.parent) {\r\n    //   minRightLeaf.parent.right = null;\r\n    // }\r\n  \r\n    return clone;\r\n  }\r\n  \r\n  \r\n  search(value) {\r\n    return this.postOrderTraverse().find((node) => node.value === value);\r\n  }\r\n  \r\n  \r\n  min(node) {\r\n    while (node.left!==null) {\r\n      node = node.left;\r\n    }\r\n    return node;\r\n  }\r\n\r\n  minimum(node = this.root) {\r\n    let current = node;\r\n    while (current !== null && current.left !== null) {\r\n      current = current.left;\r\n    }\r\n    return current;\r\n  }\r\n\r\n  max(node = this.root) {\r\n    let current = node;\r\n    while (current !== null && current.right !== null) {\r\n      current = current.right;\r\n    }\r\n    return current;\r\n  }\r\n  inOrderTraverse(node = this.root, traversed = []) {\r\n    if (node === null) {\r\n      return traversed;\r\n    }\r\n    if (node.left) {\r\n      traversed.push(...this.inOrderTraverse(node.left));\r\n    }\r\n    traversed.push(node);\r\n    if (node.right) {\r\n      traversed.push(...this.inOrderTraverse(node.right));\r\n    }\r\n    return traversed;\r\n  }\r\n  \r\n  preOrderTraverse(node = this.root, traversed = []) {\r\n    if (node === null) {\r\n      return traversed;\r\n    }\r\n    traversed.push(node);\r\n    if (node.left) {\r\n      traversed.push(...this.preOrderTraverse(node.left));\r\n    }\r\n    if (node.right) {\r\n      traversed.push(...this.preOrderTraverse(node.right));\r\n    }\r\n    return traversed;\r\n  }\r\n  \r\n  postOrderTraverse(node = this.root, traversed = []) {\r\n    if (node === null) {\r\n      return traversed;\r\n    }\r\n    if (node.left) {\r\n      traversed.push(...this.postOrderTraverse(node.left));\r\n    }\r\n    if (node.right) {\r\n      traversed.push(...this.postOrderTraverse(node.right));\r\n    }\r\n    traversed.push(node);\r\n    return traversed;\r\n  }\r\n}  \r\n\r\nexport default BinarySearchTree;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
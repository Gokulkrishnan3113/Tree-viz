{"ast":null,"code":"const COMPARISON = {\n  EQUAL: 0,\n  SMALLER: -1,\n  GREATER: 1\n};\nconst defaultCompareNumberFn = (a, b) => {\n  if (Number(a) === Number(b)) {\n    return COMPARISON.EQUAL;\n  }\n  return Number(a) < Number(b) ? COMPARISON.SMALLER : COMPARISON.GREATER;\n};\nclass TreeNode {\n  constructor(value, parent) {\n    this.value = value.toString();\n    this.parent = parent || null;\n    this.left = null;\n    this.right = null;\n  }\n  get isLeaf() {\n    return this.left === null && this.right === null;\n  }\n  get hasChildren() {\n    return !this.isLeaf;\n  }\n}\nclass BinarySearchTree {\n  constructor(compareFn = defaultCompareNumberFn) {\n    this.root = null;\n    this.compareFn = compareFn;\n  }\n  insert(value) {\n    let node = this.root;\n    let insertedNode;\n    if (node === null) {\n      this.root = new TreeNode(value);\n      return this.root;\n    }\n    const nodeInserted = (() => {\n      while (true) {\n        const comparison = this.compareFn(value, node.value);\n        if (comparison === COMPARISON.EQUAL) {\n          insertedNode = node;\n          return node;\n        }\n        if (comparison === COMPARISON.SMALLER) {\n          if (node.left === null) {\n            insertedNode = new TreeNode(value, node);\n            node.left = insertedNode;\n            return true;\n          }\n          node = node.left;\n        } else if (comparison === COMPARISON.GREATER) {\n          if (node.right === null) {\n            insertedNode = new TreeNode(value, node);\n            node.right = insertedNode;\n            return true;\n          }\n          node = node.right;\n        }\n      }\n    })();\n    if (nodeInserted) {\n      return insertedNode;\n    }\n  }\n  remove(value, node) {\n    node = node ? node : this.search(value);\n    if (!node) return null;\n    const nodeIsRoot = node.parent === null;\n    const hasBothChildren = node.left !== null && node.right !== null;\n    const isLeftChild = !nodeIsRoot ? node.parent.left === node : false;\n    if (node.isLeaf) {\n      if (nodeIsRoot) {\n        this.root = null;\n      } else if (isLeftChild) {\n        node.parent.left = null;\n      } else {\n        node.parent.right = null;\n      }\n      return node;\n    }\n    if (!hasBothChildren) {\n      const child = node.left !== null ? node.left : node.right;\n      if (nodeIsRoot) {\n        this.root = child;\n      } else if (isLeftChild) {\n        node.parent.left = child;\n      } else {\n        node.parent.right = child;\n      }\n      child.parent = node.parent;\n      return node;\n    }\n    const minRightLeaf = this.min(node.right);\n    if (minRightLeaf.parent.left === minRightLeaf) {\n      minRightLeaf.parent.left = null;\n    } else {\n      minRightLeaf.parent.right = null;\n    }\n    const clone = {\n      ...node\n    };\n    node.value = minRightLeaf.value;\n    return clone;\n  }\n  search(value) {\n    return this.postOrderTraverse().find(node => node.value === value);\n  }\n  min(node = this.root) {\n    let current = node;\n    while (current !== null && current.left !== null) {\n      current = current.left;\n    }\n    return current;\n  }\n  max(node = this.root) {\n    let current = node;\n    while (current !== null && current.right !== null) {\n      current = current.right;\n    }\n    return current;\n  }\n  inOrderTraverse(node = this.root, traversed = []) {\n    if (node === null) {\n      return traversed;\n    }\n    if (node.left) {\n      traversed.push(...this.inOrderTraverse(node.left));\n    }\n    traversed.push(node, value);\n    if (node.right) {\n      traversed.push(...this.inOrderTraverse(node.right));\n    }\n    return traversed;\n  }\n  preOrderTraverse(node = this.root, traversed = []) {\n    if (node === null) {\n      return traversed;\n    }\n    traversed.push(node, value);\n    if (node.left) {\n      traversed.push(...this.preOrderTraverse(node.left));\n    }\n    if (node.right) {\n      traversed.push(...this.preOrderTraverse(node.right));\n    }\n    return traversed;\n  }\n  postOrderTraverse(node = this.root, traversed = []) {\n    if (node === null) {\n      return traversed;\n    }\n    if (node.left) {\n      traversed.push(...this.postOrderTraverse(node.left));\n    }\n    if (node.right) {\n      traversed.push(...this.postOrderTraverse(node.right));\n    }\n    traversed.push(node, value);\n    return traversed;\n  }\n}\nexport default BinarySearchTree;","map":{"version":3,"names":["COMPARISON","EQUAL","SMALLER","GREATER","defaultCompareNumberFn","a","b","Number","TreeNode","constructor","value","parent","toString","left","right","isLeaf","hasChildren","BinarySearchTree","compareFn","root","insert","node","insertedNode","nodeInserted","comparison","remove","search","nodeIsRoot","hasBothChildren","isLeftChild","child","minRightLeaf","min","clone","postOrderTraverse","find","current","max","inOrderTraverse","traversed","push","preOrderTraverse"],"sources":["/Users/gokulkrishnan/College/project/treeviz/src/BST/js_binary_search_tree.js"],"sourcesContent":["const COMPARISON = {\r\n  EQUAL: 0,\r\n  SMALLER: -1,\r\n  GREATER: 1,\r\n};\r\n\r\nconst defaultCompareNumberFn = (a, b) => {\r\n  if (Number(a) === Number(b)) {\r\n    return COMPARISON.EQUAL;\r\n  }\r\n\r\n  return Number(a) < Number(b) ? COMPARISON.SMALLER : COMPARISON.GREATER;\r\n};\r\n\r\nclass TreeNode {\r\n  constructor(value, parent) {\r\n    this.value = value.toString();\r\n    this.parent = parent || null;\r\n    this.left = null;\r\n    this.right = null;\r\n  }\r\n\r\n  get isLeaf() {\r\n    return this.left === null && this.right === null;\r\n  }\r\n\r\n  get hasChildren() {\r\n    return !this.isLeaf;\r\n  }\r\n}\r\nclass BinarySearchTree {\r\n  root;\r\n  compareFn;\r\n  constructor(compareFn = defaultCompareNumberFn) {\r\n    this.root = null;\r\n    this.compareFn = compareFn;\r\n  }\r\n\r\n  insert(value) {\r\n    let node = this.root;\r\n    let insertedNode;\r\n    if (node === null) {\r\n      this.root = new TreeNode(value);\r\n      return this.root;\r\n    }\r\n    const nodeInserted = (() => {\r\n      while (true) {\r\n        const comparison = this.compareFn(value, node.value);\r\n        if (comparison === COMPARISON.EQUAL) {\r\n          insertedNode = node;\r\n          return node;\r\n        }\r\n        if (comparison === COMPARISON.SMALLER) {\r\n          if (node.left === null) {\r\n            insertedNode = new TreeNode(value, node);\r\n            node.left = insertedNode;\r\n            return true;\r\n          }\r\n          node = node.left;\r\n        } else if (comparison === COMPARISON.GREATER) {\r\n          if (node.right === null) {\r\n            insertedNode = new TreeNode(value, node);\r\n            node.right = insertedNode;\r\n            return true;\r\n          }\r\n          node = node.right;\r\n        }\r\n      }\r\n    })();\r\n    if (nodeInserted) {\r\n      return insertedNode;\r\n    }\r\n  }\r\n\r\n  remove(value, node) {\r\n    node = node ? node : this.search(value);\r\n    if (!node) return null;\r\n\r\n    const nodeIsRoot = node.parent === null;\r\n    const hasBothChildren = node.left !== null && node.right !== null;\r\n    const isLeftChild = !nodeIsRoot ? node.parent.left === node : false;\r\n\r\n    if (node.isLeaf) {\r\n      if (nodeIsRoot) {\r\n        this.root = null;\r\n      } else if (isLeftChild) {\r\n        node.parent.left = null;\r\n      } else {\r\n        node.parent.right = null;\r\n      }\r\n      return node;\r\n    }\r\n    if (!hasBothChildren) {\r\n      const child = node.left !== null ? node.left : node.right;\r\n      if (nodeIsRoot) {\r\n        this.root = child;\r\n      } else if (isLeftChild) {\r\n        node.parent.left = child;\r\n      } else {\r\n        node.parent.right = child;\r\n      }\r\n      child.parent = node.parent;\r\n      return node;\r\n    }\r\n\r\n    const minRightLeaf = this.min(node.right);\r\n    if (minRightLeaf.parent.left === minRightLeaf) {\r\n      minRightLeaf.parent.left = null;\r\n    } else {\r\n      minRightLeaf.parent.right = null;\r\n    }\r\n    const clone = { ...node };\r\n    node.value = minRightLeaf.value;\r\n    return clone;\r\n  }\r\n  search(value) {\r\n    return this.postOrderTraverse().find((node) => node.value === value);\r\n  }\r\n  min(node = this.root) {\r\n    let current = node;\r\n    while (current !== null && current.left !== null) {\r\n      current = current.left;\r\n    }\r\n    return current;\r\n  }\r\n  max(node = this.root) {\r\n    let current = node;\r\n    while (current !== null && current.right !== null) {\r\n      current = current.right;\r\n    }\r\n    return current;\r\n  }\r\n  inOrderTraverse(node = this.root, traversed = []) {\r\n    if (node === null) {\r\n      return traversed;\r\n    }\r\n    if (node.left) {\r\n      traversed.push(...this.inOrderTraverse(node.left));\r\n    }\r\n    traversed.push(node,value);\r\n    if (node.right) {\r\n      traversed.push(...this.inOrderTraverse(node.right));\r\n    }\r\n    return traversed;\r\n  }\r\n  preOrderTraverse(node = this.root, traversed = []) {\r\n    if (node === null) {\r\n      return traversed;\r\n    }\r\n    traversed.push(node,value);\r\n    if (node.left) {\r\n      traversed.push(...this.preOrderTraverse(node.left));\r\n    }\r\n    if (node.right) {\r\n      traversed.push(...this.preOrderTraverse(node.right));\r\n    }\r\n    return traversed;\r\n  }\r\n  postOrderTraverse(node = this.root, traversed = []) {\r\n    if (node === null) {\r\n      return traversed;\r\n    }\r\n    if (node.left) {\r\n      traversed.push(...this.postOrderTraverse(node.left));\r\n    }\r\n    if (node.right) {\r\n      traversed.push(...this.postOrderTraverse(node.right));\r\n    }\r\n    traversed.push(node,value);\r\n    return traversed;\r\n  }\r\n}\r\n\r\nexport default BinarySearchTree;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"// import BinarySearchTree from \"../BST/js_binary_search_tree\";\n// const BLACK = 'BLACK';\n// const RED = 'RED';\n\n// class Node {\n//     constructor(data, color = RED) {\n//         this.value = data;\n//         this.color = color;\n//         this.left = null;\n//         this.right = null;\n//         this.parent = undefined;\n//     }\n\n//   isLeftChild() {\n//       return this.parent && this.parent.left === this;\n//   }\n\n//   flipColor() {\n//       this.color = this.color === BLACK ? RED : BLACK;\n//   }\n// }\n\n// class RedBlackTree extends BinarySearchTree{\n//   constructor() {\n//     super();\n//   }\n\n//   rbinsert(data) {\n//     const node = new Node(data);\n//     this.root = this._insert(this.root, node);\n//     if (this.root) {\n//         this._recolorAndRotate(node);\n//     }\n// }\n\n// _insert(currentNode, newNode) {\n//   if (currentNode === null) {\n//       return newNode;\n//   }\n\n//   if (newNode.value < currentNode.value) {\n//       currentNode.left = this._insert(currentNode.left, newNode);\n//       currentNode.left.parent = currentNode; // Set the parent for the left child\n//   } else if (newNode.value > currentNode.value) {\n//       currentNode.right = this._insert(currentNode.right, newNode);\n//       currentNode.right.parent = currentNode; // Set the parent for the right child\n//   }\n\n//   return currentNode;\n// }\n\n// _recolorAndRotate(node) {\n//     const par = node.parent;\n//     //console.log(\"parent\"+par.value);\n//     if (node !== this.root && par.color === RED) {\n//         const grandParent = par.parent;\n//         const uncle = par.isLeftChild() ? grandParent.right : grandParent.left;\n\n//         if (uncle !== null && uncle.color === RED) {\n//             this._handleRecoloring(par, uncle, grandParent);\n//         } else if (par.isLeftChild()) {\n//             this._handleLeftSituations(node, par, grandParent);\n//         } else {\n//             this._handleRightSituations(node, par, grandParent);\n//         }\n//     }\n\n//     this.root.color = BLACK;\n// }\n\n//   _handleRightSituations(node, parent, grandParent) {\n//       if (node.isLeftChild()) {\n//           this._rotateRight(parent);\n//       }\n//       parent.flipColor();\n//       grandParent.flipColor();\n//       this._rotateLeft(grandParent);\n//       this._recolorAndRotate(node.isLeftChild() ? grandParent : parent);\n//   }\n\n//   _handleLeftSituations(node, parent, grandParent) {\n//       if (!node.isLeftChild()) {\n//           this._rotateLeft(parent);\n//       }\n//       parent.flipColor();\n//       grandParent.flipColor();\n//       this._rotateRight(grandParent);\n//       this._recolorAndRotate(node.isLeftChild() ? parent : grandParent);\n//   }\n\n//   _handleRecoloring(parent, uncle, grandParent) {\n//       uncle.flipColor();\n//       parent.flipColor();\n//       grandParent.flipColor();\n//       this._recolorAndRotate(grandParent);\n//   }\n\n//   _rotateRight(node) {\n//       const leftNode = node.left;\n//       node.left = leftNode.right;\n\n//       if (node.left !== null) {\n//           node.left.parent = node;\n//       }\n\n//       leftNode.right = node;\n//       leftNode.parent = node.parent;\n//       this._updateChildrenOfParentNode(node, leftNode);\n//       node.parent = leftNode;\n//   }\n\n//   _rotateLeft(node) {\n//       const rightNode = node.right;\n//       node.right = rightNode.left;\n\n//       if (node.right !== null) {\n//           node.right.parent = node;\n//       }\n\n//       rightNode.left = node;\n//       rightNode.parent = node.parent;\n//       this._updateChildrenOfParentNode(node, rightNode);\n//       node.parent = rightNode;\n//   }\n\n//   _updateChildrenOfParentNode(node, tempNode) {\n//       if (node.parent === null) {\n//           this.root = tempNode;\n//       } else if (node.isLeftChild()) {\n//           node.parent.left = tempNode;\n//       } else {\n//           node.parent.right = tempNode;\n//       }\n//   }\n\n//   traverse() {\n//       this._traverseInOrder(this.root);\n//   }\n\n//   _traverseInOrder(node) {\n//       if (node !== null) {\n//           this._traverseInOrder(node.left);\n//           console.log(node.data);\n//           this._traverseInOrder(node.right);\n//       }\n//   }\n\n//   getMax() {\n//       if (this.isEmpty()) {\n//           return null;\n//       }\n//       return this._getMax(this.root);\n//   }\n\n//   _getMax(node) {\n//       if (node.right !== null) {\n//           return this._getMax(node.right);\n//       }\n//       return node.data;\n//   }\n\n//   getMin() {\n//       if (this.isEmpty()) {\n//           return null;\n//       }\n//       return this._getMin(this.root);\n//   }\n\n//   _getMin(node) {\n//       if (node.left !== null) {\n//           return this._getMin(node.left);\n//       }\n//       return node.data;\n//   }\n\n//   isEmpty() {\n//       return this.root === null;\n//   }\n// }\n// export default RedBlackTree;","map":{"version":3,"names":[],"sources":["/Users/gokulkrishnan/College/project/treeviz/src/RB/rb.js"],"sourcesContent":["// import BinarySearchTree from \"../BST/js_binary_search_tree\";\n// const BLACK = 'BLACK';\n// const RED = 'RED';\n\n\n// class Node {\n//     constructor(data, color = RED) {\n//         this.value = data;\n//         this.color = color;\n//         this.left = null;\n//         this.right = null;\n//         this.parent = undefined;\n//     }\n\n\n//   isLeftChild() {\n//       return this.parent && this.parent.left === this;\n//   }\n\n//   flipColor() {\n//       this.color = this.color === BLACK ? RED : BLACK;\n//   }\n// }\n\n// class RedBlackTree extends BinarySearchTree{\n//   constructor() {\n//     super();\n//   }\n\n//   rbinsert(data) {\n//     const node = new Node(data);\n//     this.root = this._insert(this.root, node);\n//     if (this.root) {\n//         this._recolorAndRotate(node);\n//     }\n// }\n\n\n// _insert(currentNode, newNode) {\n//   if (currentNode === null) {\n//       return newNode;\n//   }\n\n//   if (newNode.value < currentNode.value) {\n//       currentNode.left = this._insert(currentNode.left, newNode);\n//       currentNode.left.parent = currentNode; // Set the parent for the left child\n//   } else if (newNode.value > currentNode.value) {\n//       currentNode.right = this._insert(currentNode.right, newNode);\n//       currentNode.right.parent = currentNode; // Set the parent for the right child\n//   }\n\n//   return currentNode;\n// }\n\n\n\n// _recolorAndRotate(node) {\n//     const par = node.parent;\n//     //console.log(\"parent\"+par.value);\n//     if (node !== this.root && par.color === RED) {\n//         const grandParent = par.parent;\n//         const uncle = par.isLeftChild() ? grandParent.right : grandParent.left;\n\n//         if (uncle !== null && uncle.color === RED) {\n//             this._handleRecoloring(par, uncle, grandParent);\n//         } else if (par.isLeftChild()) {\n//             this._handleLeftSituations(node, par, grandParent);\n//         } else {\n//             this._handleRightSituations(node, par, grandParent);\n//         }\n//     }\n\n//     this.root.color = BLACK;\n// }\n\n//   _handleRightSituations(node, parent, grandParent) {\n//       if (node.isLeftChild()) {\n//           this._rotateRight(parent);\n//       }\n//       parent.flipColor();\n//       grandParent.flipColor();\n//       this._rotateLeft(grandParent);\n//       this._recolorAndRotate(node.isLeftChild() ? grandParent : parent);\n//   }\n\n//   _handleLeftSituations(node, parent, grandParent) {\n//       if (!node.isLeftChild()) {\n//           this._rotateLeft(parent);\n//       }\n//       parent.flipColor();\n//       grandParent.flipColor();\n//       this._rotateRight(grandParent);\n//       this._recolorAndRotate(node.isLeftChild() ? parent : grandParent);\n//   }\n\n//   _handleRecoloring(parent, uncle, grandParent) {\n//       uncle.flipColor();\n//       parent.flipColor();\n//       grandParent.flipColor();\n//       this._recolorAndRotate(grandParent);\n//   }\n\n//   _rotateRight(node) {\n//       const leftNode = node.left;\n//       node.left = leftNode.right;\n\n//       if (node.left !== null) {\n//           node.left.parent = node;\n//       }\n\n//       leftNode.right = node;\n//       leftNode.parent = node.parent;\n//       this._updateChildrenOfParentNode(node, leftNode);\n//       node.parent = leftNode;\n//   }\n\n//   _rotateLeft(node) {\n//       const rightNode = node.right;\n//       node.right = rightNode.left;\n\n//       if (node.right !== null) {\n//           node.right.parent = node;\n//       }\n\n//       rightNode.left = node;\n//       rightNode.parent = node.parent;\n//       this._updateChildrenOfParentNode(node, rightNode);\n//       node.parent = rightNode;\n//   }\n\n//   _updateChildrenOfParentNode(node, tempNode) {\n//       if (node.parent === null) {\n//           this.root = tempNode;\n//       } else if (node.isLeftChild()) {\n//           node.parent.left = tempNode;\n//       } else {\n//           node.parent.right = tempNode;\n//       }\n//   }\n\n//   traverse() {\n//       this._traverseInOrder(this.root);\n//   }\n\n//   _traverseInOrder(node) {\n//       if (node !== null) {\n//           this._traverseInOrder(node.left);\n//           console.log(node.data);\n//           this._traverseInOrder(node.right);\n//       }\n//   }\n\n//   getMax() {\n//       if (this.isEmpty()) {\n//           return null;\n//       }\n//       return this._getMax(this.root);\n//   }\n\n//   _getMax(node) {\n//       if (node.right !== null) {\n//           return this._getMax(node.right);\n//       }\n//       return node.data;\n//   }\n\n//   getMin() {\n//       if (this.isEmpty()) {\n//           return null;\n//       }\n//       return this._getMin(this.root);\n//   }\n\n//   _getMin(node) {\n//       if (node.left !== null) {\n//           return this._getMin(node.left);\n//       }\n//       return node.data;\n//   }\n\n//   isEmpty() {\n//       return this.root === null;\n//   }\n// }\n// export default RedBlackTree;\n"],"mappings":"AAAA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAIA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA"},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import _classPrivateFieldLooseKey from \"/Users/gokulkrishnan/College/project/treeviz/node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseKey.js\";\nimport BinarySearchTree from \"../BST/js_binary_search_tree\";\nconst COLOR = Object.freeze({\n  RED: 'red',\n  BLACK: 'black'\n});\nvar _color = /*#__PURE__*/_classPrivateFieldLooseKey(\"color\");\nclass RedBlackNode {\n  constructor(key = null, parent = null) {\n    Object.defineProperty(this, _color, {\n      writable: true,\n      value: void 0\n    });\n    this.left = null;\n    this.right = null;\n    this.key = key;\n    this.parent = parent;\n    if (key == null) {\n      this.color = COLOR.BLACK;\n    } else {\n      this.color = COLOR.RED;\n      this.left = new RedBlackNode(null, this);\n      this.right = new RedBlackNode(null, this);\n    }\n  }\n  get isRed() {\n    return this.color === COLOR.RED;\n  }\n  get isBlack() {\n    return !this.isRed;\n  }\n  get isNil() {\n    return this.key === null;\n  }\n  get color() {\n    return this.color;\n  }\n  set color(newColor) {\n    if (!this.isNil) {\n      this.color = newColor;\n    }\n  }\n}\nvar _root = /*#__PURE__*/_classPrivateFieldLooseKey(\"root\");\nclass RBTREE extends BinarySearchTree {\n  constructor(compareFn = null) {\n    let fn = null;\n    if (compareFn && typeof compareFn === 'function') {\n      fn = compareFn;\n    } else {\n      fn = (a, b) => {\n        if (a > b) return BinarySearchTree.defaultCompareNumberFn.BIGGER;\n        if (a < b) return BinarySearchTree.defaultCompareNumberFn.SMALLER;\n        return BinarySearchTree.defaultCompareNumberFn.EQUAL;\n      };\n    }\n    super(fn);\n    Object.defineProperty(this, _root, {\n      writable: true,\n      value: null\n    });\n    this.insertNode = (newNode, currentNode = this.root) => {\n      if (this.compare(newNode.key, currentNode.key) === BinarySearchTree.comparison.SMALLER) {\n        if (currentNode.left.isNil) {\n          currentNode.left = newNode;\n          newNode.parent = currentNode;\n        } else {\n          this.insertNode(newNode, currentNode.left);\n        }\n      } else {\n        if (currentNode.right.isNil) {\n          currentNode.right = newNode;\n          newNode.parent = currentNode;\n        } else {\n          this.insertNode(newNode, currentNode.right);\n        }\n      }\n    };\n    this.RRotation = node => {\n      if (node.left) {\n        // console.log('r rotate', node.key);\n        const nodeParent = node.parent;\n        const detached = node.left;\n        node.left = detached.right;\n        detached.right = node;\n        node.parent = detached;\n        if (node.left !== null) {\n          node.left.parent = node;\n        }\n        if (nodeParent !== null) {\n          if (node === nodeParent.left) {\n            nodeParent.left = detached;\n          } else {\n            nodeParent.right = detached;\n          }\n        } else {\n          this.root = detached;\n        }\n        detached.parent = nodeParent;\n      }\n    };\n    this.LRotation = node => {\n      if (node.right) {\n        // console.log('l rotate', node.key);\n        const nodeParent = node.parent;\n        const detached = node.right;\n        node.right = detached.left;\n        detached.left = node;\n        node.parent = detached;\n        if (node.right !== null) {\n          node.right.parent = node;\n        }\n        if (nodeParent !== null) {\n          if (node === nodeParent.left) {\n            nodeParent.left = detached;\n          } else {\n            nodeParent.right = detached;\n          }\n        } else {\n          this.root = detached;\n        }\n        detached.parent = nodeParent;\n      }\n    };\n    this.removeNode = (key, node = this.root) => {\n      if (node === null || node.isNil) return;\n      if (this.compare(key, node.key) === BinarySearchTree.comparison.SMALLER) {\n        this.removeNode(key, node.left);\n      } else if (this.compare(key, node.key) === BinarySearchTree.comparison.BIGGER) {\n        this.removeNode(key, node.right);\n      } else if (node.left.isNil && node.right.isNil) {\n        // console.log('remove 1', node.key)\n        this.handleRemovedNode(node);\n        if (node.parent === null) {\n          this.root = null;\n        } else if (node === node.parent.left) {\n          node.parent.left = this.createNode(null, node);\n        } else {\n          node.parent.right = this.createNode(null, node);\n        }\n      } else if (node.left.isNil) {\n        // console.log('remove 2', node.key)\n        node.key = node.right.key;\n        node.right = this.createNode(null, node);\n      } else if (node.right.isNil) {\n        // console.log('remove 3', node.key)\n        node.key = node.left.key;\n        node.left = this.createNode(null, node);\n      } else {\n        const max = this.maxNode(node.left);\n        // console.log('remove 4', node.key)\n        node.key = max.key;\n        this.removeNode(max.key, node.left);\n      }\n    };\n    this.maxNode = node => {\n      while (node && !node.isNill && !node.right.isNil) {\n        node = node.right;\n      }\n      return node;\n    };\n    this.compare = fn;\n  }\n  get root() {\n    return this.root;\n  }\n  createNode(key = null, parent = null) {\n    return new RedBlackNode(key, parent);\n  }\n  insertrb(key) {\n    const newNode = this.createNode(key);\n    if (this.root === null) {\n      this.root = newNode;\n    } else {\n      this.insertNode(newNode);\n    }\n    this.adjustTreeAfterInsertion(newNode);\n  }\n  adjustTreeAfterInsertion(node) {\n    if (node.parent === null) {\n      node.color = COLOR.BLACK;\n    } else if (node.parent.isRed) {\n      const parentNode = node.parent;\n      const grandParentNode = parentNode.parent;\n      const uncleNode = grandParentNode.left === parentNode ? grandParentNode.right : grandParentNode.left;\n      if (uncleNode.isBlack) {\n        // console.log('red parent blk uncle')\n        this.handleBlackUncle(node);\n      } else {\n        // console.log('red parent red uncle')\n        this.handleRedUncle(parentNode, uncleNode, grandParentNode);\n      }\n    }\n  }\n  handleBlackUncle(node) {\n    const parentNode = node.parent;\n    if (node === parentNode.left) {\n      if (parentNode === parentNode.parent.left) {\n        this.recolorMidNode(parentNode);\n        this.RRotation(parentNode.parent);\n      } else {\n        this.RRotation(parentNode);\n        this.recolorMidNode(node);\n        this.LRotation(node.parent);\n      }\n    } else {\n      if (parentNode === parentNode.parent.right) {\n        this.recolorMidNode(parentNode);\n        this.LRotation(parentNode.parent);\n      } else {\n        this.LRotation(parentNode);\n        this.recolorMidNode(node);\n        this.RRotation(node.parent);\n      }\n    }\n  }\n  handleRedUncle(parentNode, uncleNode, grandParentNode) {\n    parentNode.color = COLOR.BLACK;\n    uncleNode.color = COLOR.BLACK;\n    grandParentNode.color = COLOR.RED;\n    this.adjustTreeAfterInsertion(grandParentNode);\n  }\n  recolorMidNode(node) {\n    node.color = COLOR.BLACK;\n    node.parent.color = COLOR.RED;\n  }\n  removerb(key) {\n    this.removeNode(key);\n  }\n  getNodeSibling(node) {\n    const parentNode = node.parent;\n    const sibNode = parentNode.left === node ? parentNode.right : parentNode.left;\n    return sibNode;\n  }\n  handleCase2(node) {\n    // sibling is red with 2 black children\n    const sibNode = this.getNodeSibling(node);\n    if (sibNode.isRed) {\n      const parentNode = node.parent;\n      sibNode.color = COLOR.BLACK;\n      parentNode.color = COLOR.RED;\n      if (node === parentNode.left) {\n        this.LRotation(parentNode);\n      } else {\n        this.RRotation(parentNode);\n      }\n    }\n    this.handleCase3(node);\n  }\n  handleCase3(node) {\n    // node parent is black, sibling and its children are black\n    const sibNode = this.getNodeSibling(node);\n    if (node.parent.isBlack && sibNode.isBlack && sibNode.left.isBlack && sibNode.right.isBlack) {\n      sibNode.color = COLOR.RED;\n      this.handleRemovedNode(node.parent);\n    } else {\n      this.handleCase4(node);\n    }\n  }\n  handleCase4(node) {\n    // node parent is red, sibling and its children are black\n    const sibNode = this.getNodeSibling(node);\n    if (node.parent.isRed && sibNode.isBlack && sibNode.left.isBlack && sibNode.right.isBlack) {\n      sibNode.color = COLOR.RED;\n      node.parent.color = COLOR.BLACK;\n    } else {\n      this.handleCase5(node);\n    }\n  }\n  handleCase5(node) {\n    // sib is black with red left and black right\n    const sibNode = this.getNodeSibling(node);\n    if (sibNode.isBlack) {\n      const parentNode = node.parent;\n      if (node === parentNode.left && sibNode.left.isRed && sibNode.right.isBlack) {\n        sibNode.color = COLOR.RED;\n        sibNode.left.color = COLOR.BLACK;\n        this.RRotation(sibNode);\n      }\n      if (node === parentNode.right && sibNode.left.isBlack && sibNode.right.isRed) {\n        sibNode.color = COLOR.RED;\n        sibNode.right.color = COLOR.BLACK;\n        this.LRotation(sibNode);\n      }\n    }\n    this.handleCase6(node);\n  }\n  handleCase6(node) {\n    // sib is black with red right and black left\n    const sibNode = this.getNodeSibling(node);\n    const parentNode = node.parent;\n    sibNode.color = parentNode.color;\n    parentNode.color = COLOR.BLACK;\n    if (node === parentNode.left) {\n      sibNode.right.color = COLOR.BLACK;\n      this.LRotation(parentNode);\n    } else {\n      sibNode.left.color = COLOR.BLACK;\n      this.RRotation(parentNode);\n    }\n  }\n  handleRemovedNode(node) {\n    // console.log('case 1', node.key);\n    // node is black and with a parent\n    if (node.isBlack && node.parent !== null) {\n      // case 1\n      this.handleCase2(node);\n    }\n  }\n}\nexport default RBTREE;","map":{"version":3,"names":["BinarySearchTree","COLOR","Object","freeze","RED","BLACK","_color","_classPrivateFieldLooseKey","RedBlackNode","constructor","key","parent","defineProperty","writable","value","left","right","color","isRed","isBlack","isNil","newColor","_root","RBTREE","compareFn","fn","a","b","defaultCompareNumberFn","BIGGER","SMALLER","EQUAL","insertNode","newNode","currentNode","root","compare","comparison","RRotation","node","nodeParent","detached","LRotation","removeNode","handleRemovedNode","createNode","max","maxNode","isNill","insertrb","adjustTreeAfterInsertion","parentNode","grandParentNode","uncleNode","handleBlackUncle","handleRedUncle","recolorMidNode","removerb","getNodeSibling","sibNode","handleCase2","handleCase3","handleCase4","handleCase5","handleCase6"],"sources":["/Users/gokulkrishnan/College/project/treeviz/src/RB/rb.js"],"sourcesContent":["import BinarySearchTree from \"../BST/js_binary_search_tree\";\nconst COLOR = Object.freeze({\n    RED: 'red',\n    BLACK: 'black'\n  })\n\n  class RedBlackNode {\n    \n    #color;\n    left = null;\n    right = null;\n    constructor(key = null, parent = null) {\n        this.key = key;\n        this.parent = parent;\n        \n        if(key == null) {\n          this.color = COLOR.BLACK;\n        } else {\n          this.color = COLOR.RED;\n          this.left = new RedBlackNode(null, this);\n          this.right = new RedBlackNode(null, this);\n        }\n      }\n      get isRed() {\n        return this.color === COLOR.RED;\n      }\n      \n      get isBlack() {\n        return !this.isRed\n      }\n      \n      get isNil() {\n        return this.key === null;\n      }\n      \n      get color() {\n        return this.color;\n      }\n      \n      set color(newColor) {\n        if(!this.isNil) {\n           this.color = newColor;\n        }\n      }\n    \n  }\n\n  class RBTREE extends BinarySearchTree{\n    #root = null;\n    compare;\n    \n    constructor(compareFn = null) {\n      let fn = null;\n      \n      if(compareFn && typeof compareFn === 'function') {\n        fn = compareFn;\n      } else {\n        fn = (a, b) => {\n          if(a > b) return BinarySearchTree.defaultCompareNumberFn.BIGGER;\n          if(a < b) return BinarySearchTree.defaultCompareNumberFn.SMALLER;\n        \n          return BinarySearchTree.defaultCompareNumberFn.EQUAL;\n        }\n      }\n  \n      super(fn);\n      this.compare = fn;\n    }\n    get root() {\n        return this.root;\n      }\n      \n      createNode(key = null, parent = null) {\n        return new RedBlackNode(key, parent);\n      }\n      \n      insertrb(key) {\n        const newNode = this.createNode(key);\n        \n        if(this.root === null) {\n          this.root = newNode;\n        } else {\n          this.insertNode(newNode);\n        }\n        \n        this.adjustTreeAfterInsertion(newNode);\n      }\n\n      insertNode = (newNode, currentNode = this.root) => {\n        if(this.compare(newNode.key, currentNode.key) === BinarySearchTree.comparison.SMALLER) {\n           if(currentNode.left.isNil) {\n             currentNode.left = newNode;\n             newNode.parent = currentNode;\n           } else {\n            this.insertNode(newNode, currentNode.left)\n          }                            \n        } else {\n           if(currentNode.right.isNil) {\n             currentNode.right = newNode;\n             newNode.parent = currentNode;\n           } else {\n             this.insertNode(newNode, currentNode.right)\n           }  \n        }\n      }\n\n      adjustTreeAfterInsertion(node) {\n        if(node.parent === null) {\n          node.color = COLOR.BLACK;\n        } else if(node.parent.isRed) {\n          const parentNode = node.parent;\n          const grandParentNode = parentNode.parent;\n          const uncleNode = grandParentNode.left === parentNode\n            ? grandParentNode.right\n            : grandParentNode.left;\n          \n          if(uncleNode.isBlack) {\n            // console.log('red parent blk uncle')\n            this.handleBlackUncle(node);\n          } else {\n            // console.log('red parent red uncle')\n            this.handleRedUncle(parentNode, uncleNode, grandParentNode)\n          }\n        }\n      }\n\n      handleBlackUncle(node) {\n        const parentNode = node.parent;\n        \n        if(node === parentNode.left) {\n          if(parentNode === parentNode.parent.left) {\n            this.recolorMidNode(parentNode);\n            this.RRotation(parentNode.parent);\n          } else {\n            this.RRotation(parentNode);\n            this.recolorMidNode(node);\n            this.LRotation(node.parent);\n          }\n        } else {\n          if(parentNode === parentNode.parent.right) {\n            this.recolorMidNode(parentNode);\n            this.LRotation(parentNode.parent);\n          } else {\n            this.LRotation(parentNode);\n            this.recolorMidNode(node);\n            this.RRotation(node.parent);\n          }\n        }\n      }\n\n      RRotation = (node) => {\n        if(node.left) {\n          // console.log('r rotate', node.key);\n          const nodeParent = node.parent;\n          const detached = node.left;\n          node.left = detached.right;\n          detached.right = node;\n          node.parent = detached;\n          \n          if(node.left !== null) {\n            node.left.parent = node;\n          }\n          \n          if(nodeParent !== null) {\n            if(node === nodeParent.left) {\n              nodeParent.left = detached;\n            } else {\n              nodeParent.right = detached;\n            }\n          } else {\n            this.root = detached;\n          }\n          \n          detached.parent = nodeParent;\n        }\n      }\n      \n      LRotation = (node) => {\n        if(node.right) {\n          // console.log('l rotate', node.key);\n          const nodeParent = node.parent;\n          const detached = node.right;\n          node.right = detached.left;\n          detached.left = node;\n          node.parent = detached;\n          \n          if(node.right !== null) {\n            node.right.parent = node;\n          }\n          \n          if(nodeParent !== null) {\n            if(node === nodeParent.left) {\n              nodeParent.left = detached;\n            } else {\n              nodeParent.right = detached;\n            }\n          } else {\n            this.root = detached;\n          }\n          \n          detached.parent = nodeParent;\n        }\n      }\n\n\n      handleRedUncle(parentNode, uncleNode, grandParentNode) {\n        parentNode.color = COLOR.BLACK;\n        uncleNode.color = COLOR.BLACK;\n        grandParentNode.color = COLOR.RED;\n        this.adjustTreeAfterInsertion(grandParentNode);\n      }\n\n      recolorMidNode(node) {\n        node.color = COLOR.BLACK;\n        node.parent.color = COLOR.RED;\n      }\n\n\n\n\n      removerb(key) {\n        this.removeNode(key);\n      }\n\n      removeNode = (key, node = this.root) => {\n        if(node === null || node.isNil) return;\n    \n        if(this.compare(key, node.key) === BinarySearchTree.comparison.SMALLER) {\n          this.removeNode(key, node.left);\n        } else if(this.compare(key, node.key) === BinarySearchTree.comparison.BIGGER) {\n          this.removeNode(key, node.right);\n        } else if(node.left.isNil && node.right.isNil) {\n          // console.log('remove 1', node.key)\n          this.handleRemovedNode(node);\n          \n          if(node.parent === null) {\n            this.root = null;\n          } else if(node === node.parent.left) {\n            node.parent.left = this.createNode(null, node);\n          } else {\n            node.parent.right = this.createNode(null, node);\n          }\n        } else if(node.left.isNil) {\n          // console.log('remove 2', node.key)\n          node.key = node.right.key;\n          node.right = this.createNode(null, node);\n        } else if(node.right.isNil) {\n          // console.log('remove 3', node.key)\n          node.key = node.left.key;\n          node.left = this.createNode(null, node);\n        } else {\n          const max = this.maxNode(node.left);\n          // console.log('remove 4', node.key)\n          node.key = max.key;\n          this.removeNode(max.key, node.left);\n        }\n      }\n      maxNode = (node) => {\n        while(node && !node.isNill && !node.right.isNil) {\n          node = node.right;\n        }\n    \n        return node;\n      }\n\n      getNodeSibling(node) {\n        const parentNode = node.parent;\n        const sibNode = parentNode.left === node\n          ? parentNode.right\n          : parentNode.left;\n        \n        return sibNode;\n      }\n\n      handleCase2(node) {\n        // sibling is red with 2 black children\n        const sibNode = this.getNodeSibling(node);\n    \n        if(sibNode.isRed) {\n          const parentNode = node.parent;\n        \n          sibNode.color = COLOR.BLACK;\n          parentNode.color = COLOR.RED;\n    \n          if(node === parentNode.left) {\n            this.LRotation(parentNode);\n          } else {\n            this.RRotation(parentNode);\n          }\n        }\n        \n        this.handleCase3(node);\n      }\n      \n      handleCase3(node) {\n        // node parent is black, sibling and its children are black\n        const sibNode = this.getNodeSibling(node);\n        \n        if(\n          node.parent.isBlack && \n          sibNode.isBlack && \n          sibNode.left.isBlack && \n          sibNode.right.isBlack\n        ) {\n          sibNode.color = COLOR.RED;\n          this.handleRemovedNode(node.parent);\n        } else {\n          this.handleCase4(node);\n        }\n      }\n      \n      handleCase4(node) {\n        // node parent is red, sibling and its children are black\n        const sibNode = this.getNodeSibling(node);\n        \n        if(\n          node.parent.isRed && \n          sibNode.isBlack && \n          sibNode.left.isBlack && \n          sibNode.right.isBlack\n        ) {\n          sibNode.color = COLOR.RED;\n          node.parent.color = COLOR.BLACK;\n        } else {\n          this.handleCase5(node);\n        }\n      }\n      \n      handleCase5(node) {\n        // sib is black with red left and black right\n        const sibNode = this.getNodeSibling(node);\n        \n        if(sibNode.isBlack) {\n          const parentNode = node.parent;\n        \n          if(node === parentNode.left && sibNode.left.isRed && sibNode.right.isBlack) {\n            sibNode.color = COLOR.RED;\n            sibNode.left.color = COLOR.BLACK;\n            this.RRotation(sibNode);\n          }\n    \n          if(node === parentNode.right && sibNode.left.isBlack && sibNode.right.isRed) {\n            sibNode.color = COLOR.RED;\n            sibNode.right.color = COLOR.BLACK;\n            this.LRotation(sibNode);\n          }\n        }\n       \n        this.handleCase6(node);\n      }\n      \n      handleCase6(node) {\n        // sib is black with red right and black left\n        const sibNode = this.getNodeSibling(node);\n        const parentNode = node.parent;\n          \n        sibNode.color = parentNode.color;\n        parentNode.color = COLOR.BLACK;\n    \n        if(node === parentNode.left) {\n          sibNode.right.color = COLOR.BLACK;\n          this.LRotation(parentNode);\n        } else {\n          sibNode.left.color = COLOR.BLACK;\n          this.RRotation(parentNode);\n        }\n      }\n      \n      handleRemovedNode(node) {\n        // console.log('case 1', node.key);\n        // node is black and with a parent\n        if(node.isBlack && node.parent !== null) {// case 1\n          this.handleCase2(node);\n        }\n      }\n      \n\n  }\nexport default RBTREE;"],"mappings":";AAAA,OAAOA,gBAAgB,MAAM,8BAA8B;AAC3D,MAAMC,KAAK,GAAGC,MAAM,CAACC,MAAM,CAAC;EACxBC,GAAG,EAAE,KAAK;EACVC,KAAK,EAAE;AACT,CAAC,CAAC;AAAA,IAAAC,MAAA,gBAAAC,0BAAA;AAEF,MAAMC,YAAY,CAAC;EAKjBC,WAAWA,CAACC,GAAG,GAAG,IAAI,EAAEC,MAAM,GAAG,IAAI,EAAE;IAAAT,MAAA,CAAAU,cAAA,OAAAN,MAAA;MAAAO,QAAA;MAAAC,KAAA;IAAA;IAAA,KAFvCC,IAAI,GAAG,IAAI;IAAA,KACXC,KAAK,GAAG,IAAI;IAER,IAAI,CAACN,GAAG,GAAGA,GAAG;IACd,IAAI,CAACC,MAAM,GAAGA,MAAM;IAEpB,IAAGD,GAAG,IAAI,IAAI,EAAE;MACd,IAAI,CAACO,KAAK,GAAGhB,KAAK,CAACI,KAAK;IAC1B,CAAC,MAAM;MACL,IAAI,CAACY,KAAK,GAAGhB,KAAK,CAACG,GAAG;MACtB,IAAI,CAACW,IAAI,GAAG,IAAIP,YAAY,CAAC,IAAI,EAAE,IAAI,CAAC;MACxC,IAAI,CAACQ,KAAK,GAAG,IAAIR,YAAY,CAAC,IAAI,EAAE,IAAI,CAAC;IAC3C;EACF;EACA,IAAIU,KAAKA,CAAA,EAAG;IACV,OAAO,IAAI,CAACD,KAAK,KAAKhB,KAAK,CAACG,GAAG;EACjC;EAEA,IAAIe,OAAOA,CAAA,EAAG;IACZ,OAAO,CAAC,IAAI,CAACD,KAAK;EACpB;EAEA,IAAIE,KAAKA,CAAA,EAAG;IACV,OAAO,IAAI,CAACV,GAAG,KAAK,IAAI;EAC1B;EAEA,IAAIO,KAAKA,CAAA,EAAG;IACV,OAAO,IAAI,CAACA,KAAK;EACnB;EAEA,IAAIA,KAAKA,CAACI,QAAQ,EAAE;IAClB,IAAG,CAAC,IAAI,CAACD,KAAK,EAAE;MACb,IAAI,CAACH,KAAK,GAAGI,QAAQ;IACxB;EACF;AAEJ;AAAC,IAAAC,KAAA,gBAAAf,0BAAA;AAED,MAAMgB,MAAM,SAASvB,gBAAgB;EAInCS,WAAWA,CAACe,SAAS,GAAG,IAAI,EAAE;IAC5B,IAAIC,EAAE,GAAG,IAAI;IAEb,IAAGD,SAAS,IAAI,OAAOA,SAAS,KAAK,UAAU,EAAE;MAC/CC,EAAE,GAAGD,SAAS;IAChB,CAAC,MAAM;MACLC,EAAE,GAAGA,CAACC,CAAC,EAAEC,CAAC,KAAK;QACb,IAAGD,CAAC,GAAGC,CAAC,EAAE,OAAO3B,gBAAgB,CAAC4B,sBAAsB,CAACC,MAAM;QAC/D,IAAGH,CAAC,GAAGC,CAAC,EAAE,OAAO3B,gBAAgB,CAAC4B,sBAAsB,CAACE,OAAO;QAEhE,OAAO9B,gBAAgB,CAAC4B,sBAAsB,CAACG,KAAK;MACtD,CAAC;IACH;IAEA,KAAK,CAACN,EAAE,CAAC;IAACvB,MAAA,CAAAU,cAAA,OAAAU,KAAA;MAAAT,QAAA;MAAAC,KAAA,EAjBJ;IAAI;IAAA,KAwCVkB,UAAU,GAAG,CAACC,OAAO,EAAEC,WAAW,GAAG,IAAI,CAACC,IAAI,KAAK;MACjD,IAAG,IAAI,CAACC,OAAO,CAACH,OAAO,CAACvB,GAAG,EAAEwB,WAAW,CAACxB,GAAG,CAAC,KAAKV,gBAAgB,CAACqC,UAAU,CAACP,OAAO,EAAE;QACpF,IAAGI,WAAW,CAACnB,IAAI,CAACK,KAAK,EAAE;UACzBc,WAAW,CAACnB,IAAI,GAAGkB,OAAO;UAC1BA,OAAO,CAACtB,MAAM,GAAGuB,WAAW;QAC9B,CAAC,MAAM;UACN,IAAI,CAACF,UAAU,CAACC,OAAO,EAAEC,WAAW,CAACnB,IAAI,CAAC;QAC5C;MACF,CAAC,MAAM;QACJ,IAAGmB,WAAW,CAAClB,KAAK,CAACI,KAAK,EAAE;UAC1Bc,WAAW,CAAClB,KAAK,GAAGiB,OAAO;UAC3BA,OAAO,CAACtB,MAAM,GAAGuB,WAAW;QAC9B,CAAC,MAAM;UACL,IAAI,CAACF,UAAU,CAACC,OAAO,EAAEC,WAAW,CAAClB,KAAK,CAAC;QAC7C;MACH;IACF,CAAC;IAAA,KA8CDsB,SAAS,GAAIC,IAAI,IAAK;MACpB,IAAGA,IAAI,CAACxB,IAAI,EAAE;QACZ;QACA,MAAMyB,UAAU,GAAGD,IAAI,CAAC5B,MAAM;QAC9B,MAAM8B,QAAQ,GAAGF,IAAI,CAACxB,IAAI;QAC1BwB,IAAI,CAACxB,IAAI,GAAG0B,QAAQ,CAACzB,KAAK;QAC1ByB,QAAQ,CAACzB,KAAK,GAAGuB,IAAI;QACrBA,IAAI,CAAC5B,MAAM,GAAG8B,QAAQ;QAEtB,IAAGF,IAAI,CAACxB,IAAI,KAAK,IAAI,EAAE;UACrBwB,IAAI,CAACxB,IAAI,CAACJ,MAAM,GAAG4B,IAAI;QACzB;QAEA,IAAGC,UAAU,KAAK,IAAI,EAAE;UACtB,IAAGD,IAAI,KAAKC,UAAU,CAACzB,IAAI,EAAE;YAC3ByB,UAAU,CAACzB,IAAI,GAAG0B,QAAQ;UAC5B,CAAC,MAAM;YACLD,UAAU,CAACxB,KAAK,GAAGyB,QAAQ;UAC7B;QACF,CAAC,MAAM;UACL,IAAI,CAACN,IAAI,GAAGM,QAAQ;QACtB;QAEAA,QAAQ,CAAC9B,MAAM,GAAG6B,UAAU;MAC9B;IACF,CAAC;IAAA,KAEDE,SAAS,GAAIH,IAAI,IAAK;MACpB,IAAGA,IAAI,CAACvB,KAAK,EAAE;QACb;QACA,MAAMwB,UAAU,GAAGD,IAAI,CAAC5B,MAAM;QAC9B,MAAM8B,QAAQ,GAAGF,IAAI,CAACvB,KAAK;QAC3BuB,IAAI,CAACvB,KAAK,GAAGyB,QAAQ,CAAC1B,IAAI;QAC1B0B,QAAQ,CAAC1B,IAAI,GAAGwB,IAAI;QACpBA,IAAI,CAAC5B,MAAM,GAAG8B,QAAQ;QAEtB,IAAGF,IAAI,CAACvB,KAAK,KAAK,IAAI,EAAE;UACtBuB,IAAI,CAACvB,KAAK,CAACL,MAAM,GAAG4B,IAAI;QAC1B;QAEA,IAAGC,UAAU,KAAK,IAAI,EAAE;UACtB,IAAGD,IAAI,KAAKC,UAAU,CAACzB,IAAI,EAAE;YAC3ByB,UAAU,CAACzB,IAAI,GAAG0B,QAAQ;UAC5B,CAAC,MAAM;YACLD,UAAU,CAACxB,KAAK,GAAGyB,QAAQ;UAC7B;QACF,CAAC,MAAM;UACL,IAAI,CAACN,IAAI,GAAGM,QAAQ;QACtB;QAEAA,QAAQ,CAAC9B,MAAM,GAAG6B,UAAU;MAC9B;IACF,CAAC;IAAA,KAsBDG,UAAU,GAAG,CAACjC,GAAG,EAAE6B,IAAI,GAAG,IAAI,CAACJ,IAAI,KAAK;MACtC,IAAGI,IAAI,KAAK,IAAI,IAAIA,IAAI,CAACnB,KAAK,EAAE;MAEhC,IAAG,IAAI,CAACgB,OAAO,CAAC1B,GAAG,EAAE6B,IAAI,CAAC7B,GAAG,CAAC,KAAKV,gBAAgB,CAACqC,UAAU,CAACP,OAAO,EAAE;QACtE,IAAI,CAACa,UAAU,CAACjC,GAAG,EAAE6B,IAAI,CAACxB,IAAI,CAAC;MACjC,CAAC,MAAM,IAAG,IAAI,CAACqB,OAAO,CAAC1B,GAAG,EAAE6B,IAAI,CAAC7B,GAAG,CAAC,KAAKV,gBAAgB,CAACqC,UAAU,CAACR,MAAM,EAAE;QAC5E,IAAI,CAACc,UAAU,CAACjC,GAAG,EAAE6B,IAAI,CAACvB,KAAK,CAAC;MAClC,CAAC,MAAM,IAAGuB,IAAI,CAACxB,IAAI,CAACK,KAAK,IAAImB,IAAI,CAACvB,KAAK,CAACI,KAAK,EAAE;QAC7C;QACA,IAAI,CAACwB,iBAAiB,CAACL,IAAI,CAAC;QAE5B,IAAGA,IAAI,CAAC5B,MAAM,KAAK,IAAI,EAAE;UACvB,IAAI,CAACwB,IAAI,GAAG,IAAI;QAClB,CAAC,MAAM,IAAGI,IAAI,KAAKA,IAAI,CAAC5B,MAAM,CAACI,IAAI,EAAE;UACnCwB,IAAI,CAAC5B,MAAM,CAACI,IAAI,GAAG,IAAI,CAAC8B,UAAU,CAAC,IAAI,EAAEN,IAAI,CAAC;QAChD,CAAC,MAAM;UACLA,IAAI,CAAC5B,MAAM,CAACK,KAAK,GAAG,IAAI,CAAC6B,UAAU,CAAC,IAAI,EAAEN,IAAI,CAAC;QACjD;MACF,CAAC,MAAM,IAAGA,IAAI,CAACxB,IAAI,CAACK,KAAK,EAAE;QACzB;QACAmB,IAAI,CAAC7B,GAAG,GAAG6B,IAAI,CAACvB,KAAK,CAACN,GAAG;QACzB6B,IAAI,CAACvB,KAAK,GAAG,IAAI,CAAC6B,UAAU,CAAC,IAAI,EAAEN,IAAI,CAAC;MAC1C,CAAC,MAAM,IAAGA,IAAI,CAACvB,KAAK,CAACI,KAAK,EAAE;QAC1B;QACAmB,IAAI,CAAC7B,GAAG,GAAG6B,IAAI,CAACxB,IAAI,CAACL,GAAG;QACxB6B,IAAI,CAACxB,IAAI,GAAG,IAAI,CAAC8B,UAAU,CAAC,IAAI,EAAEN,IAAI,CAAC;MACzC,CAAC,MAAM;QACL,MAAMO,GAAG,GAAG,IAAI,CAACC,OAAO,CAACR,IAAI,CAACxB,IAAI,CAAC;QACnC;QACAwB,IAAI,CAAC7B,GAAG,GAAGoC,GAAG,CAACpC,GAAG;QAClB,IAAI,CAACiC,UAAU,CAACG,GAAG,CAACpC,GAAG,EAAE6B,IAAI,CAACxB,IAAI,CAAC;MACrC;IACF,CAAC;IAAA,KACDgC,OAAO,GAAIR,IAAI,IAAK;MAClB,OAAMA,IAAI,IAAI,CAACA,IAAI,CAACS,MAAM,IAAI,CAACT,IAAI,CAACvB,KAAK,CAACI,KAAK,EAAE;QAC/CmB,IAAI,GAAGA,IAAI,CAACvB,KAAK;MACnB;MAEA,OAAOuB,IAAI;IACb,CAAC;IArMD,IAAI,CAACH,OAAO,GAAGX,EAAE;EACnB;EACA,IAAIU,IAAIA,CAAA,EAAG;IACP,OAAO,IAAI,CAACA,IAAI;EAClB;EAEAU,UAAUA,CAACnC,GAAG,GAAG,IAAI,EAAEC,MAAM,GAAG,IAAI,EAAE;IACpC,OAAO,IAAIH,YAAY,CAACE,GAAG,EAAEC,MAAM,CAAC;EACtC;EAEAsC,QAAQA,CAACvC,GAAG,EAAE;IACZ,MAAMuB,OAAO,GAAG,IAAI,CAACY,UAAU,CAACnC,GAAG,CAAC;IAEpC,IAAG,IAAI,CAACyB,IAAI,KAAK,IAAI,EAAE;MACrB,IAAI,CAACA,IAAI,GAAGF,OAAO;IACrB,CAAC,MAAM;MACL,IAAI,CAACD,UAAU,CAACC,OAAO,CAAC;IAC1B;IAEA,IAAI,CAACiB,wBAAwB,CAACjB,OAAO,CAAC;EACxC;EAoBAiB,wBAAwBA,CAACX,IAAI,EAAE;IAC7B,IAAGA,IAAI,CAAC5B,MAAM,KAAK,IAAI,EAAE;MACvB4B,IAAI,CAACtB,KAAK,GAAGhB,KAAK,CAACI,KAAK;IAC1B,CAAC,MAAM,IAAGkC,IAAI,CAAC5B,MAAM,CAACO,KAAK,EAAE;MAC3B,MAAMiC,UAAU,GAAGZ,IAAI,CAAC5B,MAAM;MAC9B,MAAMyC,eAAe,GAAGD,UAAU,CAACxC,MAAM;MACzC,MAAM0C,SAAS,GAAGD,eAAe,CAACrC,IAAI,KAAKoC,UAAU,GACjDC,eAAe,CAACpC,KAAK,GACrBoC,eAAe,CAACrC,IAAI;MAExB,IAAGsC,SAAS,CAAClC,OAAO,EAAE;QACpB;QACA,IAAI,CAACmC,gBAAgB,CAACf,IAAI,CAAC;MAC7B,CAAC,MAAM;QACL;QACA,IAAI,CAACgB,cAAc,CAACJ,UAAU,EAAEE,SAAS,EAAED,eAAe,CAAC;MAC7D;IACF;EACF;EAEAE,gBAAgBA,CAACf,IAAI,EAAE;IACrB,MAAMY,UAAU,GAAGZ,IAAI,CAAC5B,MAAM;IAE9B,IAAG4B,IAAI,KAAKY,UAAU,CAACpC,IAAI,EAAE;MAC3B,IAAGoC,UAAU,KAAKA,UAAU,CAACxC,MAAM,CAACI,IAAI,EAAE;QACxC,IAAI,CAACyC,cAAc,CAACL,UAAU,CAAC;QAC/B,IAAI,CAACb,SAAS,CAACa,UAAU,CAACxC,MAAM,CAAC;MACnC,CAAC,MAAM;QACL,IAAI,CAAC2B,SAAS,CAACa,UAAU,CAAC;QAC1B,IAAI,CAACK,cAAc,CAACjB,IAAI,CAAC;QACzB,IAAI,CAACG,SAAS,CAACH,IAAI,CAAC5B,MAAM,CAAC;MAC7B;IACF,CAAC,MAAM;MACL,IAAGwC,UAAU,KAAKA,UAAU,CAACxC,MAAM,CAACK,KAAK,EAAE;QACzC,IAAI,CAACwC,cAAc,CAACL,UAAU,CAAC;QAC/B,IAAI,CAACT,SAAS,CAACS,UAAU,CAACxC,MAAM,CAAC;MACnC,CAAC,MAAM;QACL,IAAI,CAAC+B,SAAS,CAACS,UAAU,CAAC;QAC1B,IAAI,CAACK,cAAc,CAACjB,IAAI,CAAC;QACzB,IAAI,CAACD,SAAS,CAACC,IAAI,CAAC5B,MAAM,CAAC;MAC7B;IACF;EACF;EAyDA4C,cAAcA,CAACJ,UAAU,EAAEE,SAAS,EAAED,eAAe,EAAE;IACrDD,UAAU,CAAClC,KAAK,GAAGhB,KAAK,CAACI,KAAK;IAC9BgD,SAAS,CAACpC,KAAK,GAAGhB,KAAK,CAACI,KAAK;IAC7B+C,eAAe,CAACnC,KAAK,GAAGhB,KAAK,CAACG,GAAG;IACjC,IAAI,CAAC8C,wBAAwB,CAACE,eAAe,CAAC;EAChD;EAEAI,cAAcA,CAACjB,IAAI,EAAE;IACnBA,IAAI,CAACtB,KAAK,GAAGhB,KAAK,CAACI,KAAK;IACxBkC,IAAI,CAAC5B,MAAM,CAACM,KAAK,GAAGhB,KAAK,CAACG,GAAG;EAC/B;EAKAqD,QAAQA,CAAC/C,GAAG,EAAE;IACZ,IAAI,CAACiC,UAAU,CAACjC,GAAG,CAAC;EACtB;EA2CAgD,cAAcA,CAACnB,IAAI,EAAE;IACnB,MAAMY,UAAU,GAAGZ,IAAI,CAAC5B,MAAM;IAC9B,MAAMgD,OAAO,GAAGR,UAAU,CAACpC,IAAI,KAAKwB,IAAI,GACpCY,UAAU,CAACnC,KAAK,GAChBmC,UAAU,CAACpC,IAAI;IAEnB,OAAO4C,OAAO;EAChB;EAEAC,WAAWA,CAACrB,IAAI,EAAE;IAChB;IACA,MAAMoB,OAAO,GAAG,IAAI,CAACD,cAAc,CAACnB,IAAI,CAAC;IAEzC,IAAGoB,OAAO,CAACzC,KAAK,EAAE;MAChB,MAAMiC,UAAU,GAAGZ,IAAI,CAAC5B,MAAM;MAE9BgD,OAAO,CAAC1C,KAAK,GAAGhB,KAAK,CAACI,KAAK;MAC3B8C,UAAU,CAAClC,KAAK,GAAGhB,KAAK,CAACG,GAAG;MAE5B,IAAGmC,IAAI,KAAKY,UAAU,CAACpC,IAAI,EAAE;QAC3B,IAAI,CAAC2B,SAAS,CAACS,UAAU,CAAC;MAC5B,CAAC,MAAM;QACL,IAAI,CAACb,SAAS,CAACa,UAAU,CAAC;MAC5B;IACF;IAEA,IAAI,CAACU,WAAW,CAACtB,IAAI,CAAC;EACxB;EAEAsB,WAAWA,CAACtB,IAAI,EAAE;IAChB;IACA,MAAMoB,OAAO,GAAG,IAAI,CAACD,cAAc,CAACnB,IAAI,CAAC;IAEzC,IACEA,IAAI,CAAC5B,MAAM,CAACQ,OAAO,IACnBwC,OAAO,CAACxC,OAAO,IACfwC,OAAO,CAAC5C,IAAI,CAACI,OAAO,IACpBwC,OAAO,CAAC3C,KAAK,CAACG,OAAO,EACrB;MACAwC,OAAO,CAAC1C,KAAK,GAAGhB,KAAK,CAACG,GAAG;MACzB,IAAI,CAACwC,iBAAiB,CAACL,IAAI,CAAC5B,MAAM,CAAC;IACrC,CAAC,MAAM;MACL,IAAI,CAACmD,WAAW,CAACvB,IAAI,CAAC;IACxB;EACF;EAEAuB,WAAWA,CAACvB,IAAI,EAAE;IAChB;IACA,MAAMoB,OAAO,GAAG,IAAI,CAACD,cAAc,CAACnB,IAAI,CAAC;IAEzC,IACEA,IAAI,CAAC5B,MAAM,CAACO,KAAK,IACjByC,OAAO,CAACxC,OAAO,IACfwC,OAAO,CAAC5C,IAAI,CAACI,OAAO,IACpBwC,OAAO,CAAC3C,KAAK,CAACG,OAAO,EACrB;MACAwC,OAAO,CAAC1C,KAAK,GAAGhB,KAAK,CAACG,GAAG;MACzBmC,IAAI,CAAC5B,MAAM,CAACM,KAAK,GAAGhB,KAAK,CAACI,KAAK;IACjC,CAAC,MAAM;MACL,IAAI,CAAC0D,WAAW,CAACxB,IAAI,CAAC;IACxB;EACF;EAEAwB,WAAWA,CAACxB,IAAI,EAAE;IAChB;IACA,MAAMoB,OAAO,GAAG,IAAI,CAACD,cAAc,CAACnB,IAAI,CAAC;IAEzC,IAAGoB,OAAO,CAACxC,OAAO,EAAE;MAClB,MAAMgC,UAAU,GAAGZ,IAAI,CAAC5B,MAAM;MAE9B,IAAG4B,IAAI,KAAKY,UAAU,CAACpC,IAAI,IAAI4C,OAAO,CAAC5C,IAAI,CAACG,KAAK,IAAIyC,OAAO,CAAC3C,KAAK,CAACG,OAAO,EAAE;QAC1EwC,OAAO,CAAC1C,KAAK,GAAGhB,KAAK,CAACG,GAAG;QACzBuD,OAAO,CAAC5C,IAAI,CAACE,KAAK,GAAGhB,KAAK,CAACI,KAAK;QAChC,IAAI,CAACiC,SAAS,CAACqB,OAAO,CAAC;MACzB;MAEA,IAAGpB,IAAI,KAAKY,UAAU,CAACnC,KAAK,IAAI2C,OAAO,CAAC5C,IAAI,CAACI,OAAO,IAAIwC,OAAO,CAAC3C,KAAK,CAACE,KAAK,EAAE;QAC3EyC,OAAO,CAAC1C,KAAK,GAAGhB,KAAK,CAACG,GAAG;QACzBuD,OAAO,CAAC3C,KAAK,CAACC,KAAK,GAAGhB,KAAK,CAACI,KAAK;QACjC,IAAI,CAACqC,SAAS,CAACiB,OAAO,CAAC;MACzB;IACF;IAEA,IAAI,CAACK,WAAW,CAACzB,IAAI,CAAC;EACxB;EAEAyB,WAAWA,CAACzB,IAAI,EAAE;IAChB;IACA,MAAMoB,OAAO,GAAG,IAAI,CAACD,cAAc,CAACnB,IAAI,CAAC;IACzC,MAAMY,UAAU,GAAGZ,IAAI,CAAC5B,MAAM;IAE9BgD,OAAO,CAAC1C,KAAK,GAAGkC,UAAU,CAAClC,KAAK;IAChCkC,UAAU,CAAClC,KAAK,GAAGhB,KAAK,CAACI,KAAK;IAE9B,IAAGkC,IAAI,KAAKY,UAAU,CAACpC,IAAI,EAAE;MAC3B4C,OAAO,CAAC3C,KAAK,CAACC,KAAK,GAAGhB,KAAK,CAACI,KAAK;MACjC,IAAI,CAACqC,SAAS,CAACS,UAAU,CAAC;IAC5B,CAAC,MAAM;MACLQ,OAAO,CAAC5C,IAAI,CAACE,KAAK,GAAGhB,KAAK,CAACI,KAAK;MAChC,IAAI,CAACiC,SAAS,CAACa,UAAU,CAAC;IAC5B;EACF;EAEAP,iBAAiBA,CAACL,IAAI,EAAE;IACtB;IACA;IACA,IAAGA,IAAI,CAACpB,OAAO,IAAIoB,IAAI,CAAC5B,MAAM,KAAK,IAAI,EAAE;MAAC;MACxC,IAAI,CAACiD,WAAW,CAACrB,IAAI,CAAC;IACxB;EACF;AAGJ;AACF,eAAehB,MAAM"},"metadata":{},"sourceType":"module","externalDependencies":[]}
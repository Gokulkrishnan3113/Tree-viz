{"ast":null,"code":"import BinarySearchTree from \"../BST/js_binary_search_tree\";\nconst BLACK = 'BLACK';\nconst RED = 'RED';\nclass Node {\n  constructor(data, color = RED) {\n    this.data = data;\n    this.color = color;\n    this.left = null;\n    this.right = null;\n    this.parent = null;\n  }\n  isLeftChild() {\n    return this.parent && this.parent.left === this;\n  }\n  flipColor() {\n    this.color = this.color === BLACK ? RED : BLACK;\n  }\n}\nclass RedBlackTree extends BinarySearchTree {\n  constructor() {\n    super();\n  }\n  insert(data) {\n    let nnode = this.root;\n    let insertedNode;\n    if (nnode === null) {\n      this.root = new Node(value);\n      return this.root;\n    }\n    console.log(\"afterinsertcall\" + data);\n    const node = new Node(data, RED);\n    this.root = this._insert(this.root, node);\n    console.log(\"insert\" + this.root.value);\n    this._recolorAndRotate(node);\n  }\n  _insert(currentNode, newNode) {\n    if (currentNode === null) {\n      return newNode;\n    }\n    if (newNode.data < currentNode.data) {\n      currentNode.left = this._insert(currentNode.left, newNode);\n      currentNode.left.parent = currentNode;\n    } else if (newNode.data > currentNode.data) {\n      currentNode.right = this._insert(currentNode.right, newNode);\n      currentNode.right.parent = currentNode;\n    }\n    return currentNode;\n  }\n  _recolorAndRotate(node) {\n    const parent = node.parent;\n    if (node !== this.root && parent.color === RED) {\n      const grandParent = parent.parent;\n      const uncle = parent.isLeftChild() ? grandParent.right : grandParent.left;\n      if (uncle !== null && uncle.color === RED) {\n        this._handleRecoloring(parent, uncle, grandParent);\n      } else if (parent.isLeftChild()) {\n        this._handleLeftSituations(node, parent, grandParent);\n      } else {\n        this._handleRightSituations(node, parent, grandParent);\n      }\n    }\n    this.root.color = BLACK;\n  }\n  _handleRightSituations(node, parent, grandParent) {\n    if (node.isLeftChild()) {\n      this._rotateRight(parent);\n    }\n    parent.flipColor();\n    grandParent.flipColor();\n    this._rotateLeft(grandParent);\n    this._recolorAndRotate(node.isLeftChild() ? grandParent : parent);\n  }\n  _handleLeftSituations(node, parent, grandParent) {\n    if (!node.isLeftChild()) {\n      this._rotateLeft(parent);\n    }\n    parent.flipColor();\n    grandParent.flipColor();\n    this._rotateRight(grandParent);\n    this._recolorAndRotate(node.isLeftChild() ? parent : grandParent);\n  }\n  _handleRecoloring(parent, uncle, grandParent) {\n    uncle.flipColor();\n    parent.flipColor();\n    grandParent.flipColor();\n    this._recolorAndRotate(grandParent);\n  }\n  _rotateRight(node) {\n    const leftNode = node.left;\n    node.left = leftNode.right;\n    if (node.left !== null) {\n      node.left.parent = node;\n    }\n    leftNode.right = node;\n    leftNode.parent = node.parent;\n    this._updateChildrenOfParentNode(node, leftNode);\n    node.parent = leftNode;\n  }\n  _rotateLeft(node) {\n    const rightNode = node.right;\n    node.right = rightNode.left;\n    if (node.right !== null) {\n      node.right.parent = node;\n    }\n    rightNode.left = node;\n    rightNode.parent = node.parent;\n    this._updateChildrenOfParentNode(node, rightNode);\n    node.parent = rightNode;\n  }\n  _updateChildrenOfParentNode(node, tempNode) {\n    if (node.parent === null) {\n      this.root = tempNode;\n    } else if (node.isLeftChild()) {\n      node.parent.left = tempNode;\n    } else {\n      node.parent.right = tempNode;\n    }\n  }\n  traverse() {\n    this._traverseInOrder(this.root);\n  }\n  _traverseInOrder(node) {\n    if (node !== null) {\n      this._traverseInOrder(node.left);\n      console.log(node.data);\n      this._traverseInOrder(node.right);\n    }\n  }\n  getMax() {\n    if (this.isEmpty()) {\n      return null;\n    }\n    return this._getMax(this.root);\n  }\n  _getMax(node) {\n    if (node.right !== null) {\n      return this._getMax(node.right);\n    }\n    return node.data;\n  }\n  getMin() {\n    if (this.isEmpty()) {\n      return null;\n    }\n    return this._getMin(this.root);\n  }\n  _getMin(node) {\n    if (node.left !== null) {\n      return this._getMin(node.left);\n    }\n    return node.data;\n  }\n  isEmpty() {\n    return this.root === null;\n  }\n}\nexport default RedBlackTree;","map":{"version":3,"names":["BinarySearchTree","BLACK","RED","Node","constructor","data","color","left","right","parent","isLeftChild","flipColor","RedBlackTree","insert","nnode","root","insertedNode","value","console","log","node","_insert","_recolorAndRotate","currentNode","newNode","grandParent","uncle","_handleRecoloring","_handleLeftSituations","_handleRightSituations","_rotateRight","_rotateLeft","leftNode","_updateChildrenOfParentNode","rightNode","tempNode","traverse","_traverseInOrder","getMax","isEmpty","_getMax","getMin","_getMin"],"sources":["/Users/gokulkrishnan/College/project/treeviz/src/RB/rb.js"],"sourcesContent":["import BinarySearchTree from \"../BST/js_binary_search_tree\";\nconst BLACK = 'BLACK';\nconst RED = 'RED';\n\nclass Node {\n    constructor(data, color = RED) {\n        this.data = data;\n        this.color = color;\n        this.left = null;\n        this.right = null;\n        this.parent = null;\n    }\n\n\n  isLeftChild() {\n      return this.parent && this.parent.left === this;\n  }\n\n  flipColor() {\n      this.color = this.color === BLACK ? RED : BLACK;\n  }\n}\n\nclass RedBlackTree extends BinarySearchTree{\n  constructor() {\n    super();\n  }\n\n  insert(data) {\n    let nnode = this.root;\n    let insertedNode;\n    if (nnode === null) {\n      this.root = new Node(value);\n      return this.root;\n    }\n    console.log(\"afterinsertcall\"+data);\n      const node = new Node(data, RED);\n      this.root = this._insert(this.root, node);\n      console.log(\"insert\"+this.root.value);\n      this._recolorAndRotate(node);\n  }\n\n  _insert(currentNode, newNode) {\n      if (currentNode === null) {\n          return newNode;\n      }\n\n      if (newNode.data < currentNode.data) {\n          currentNode.left = this._insert(currentNode.left, newNode);\n          currentNode.left.parent = currentNode;\n      } else if (newNode.data > currentNode.data) {\n          currentNode.right = this._insert(currentNode.right, newNode);\n          currentNode.right.parent = currentNode;\n      }\n\n      return currentNode;\n  }\n\n  _recolorAndRotate(node) {\n      const parent = node.parent;\n      if (node !== this.root && parent.color === RED) {\n          const grandParent = parent.parent;\n          const uncle = parent.isLeftChild() ? grandParent.right : grandParent.left;\n\n          if (uncle !== null && uncle.color === RED) {\n              this._handleRecoloring(parent, uncle, grandParent);\n          } else if (parent.isLeftChild()) {\n              this._handleLeftSituations(node, parent, grandParent);\n          } else {\n              this._handleRightSituations(node, parent, grandParent);\n          }\n      }\n\n      this.root.color = BLACK;\n  }\n\n  _handleRightSituations(node, parent, grandParent) {\n      if (node.isLeftChild()) {\n          this._rotateRight(parent);\n      }\n      parent.flipColor();\n      grandParent.flipColor();\n      this._rotateLeft(grandParent);\n      this._recolorAndRotate(node.isLeftChild() ? grandParent : parent);\n  }\n\n  _handleLeftSituations(node, parent, grandParent) {\n      if (!node.isLeftChild()) {\n          this._rotateLeft(parent);\n      }\n      parent.flipColor();\n      grandParent.flipColor();\n      this._rotateRight(grandParent);\n      this._recolorAndRotate(node.isLeftChild() ? parent : grandParent);\n  }\n\n  _handleRecoloring(parent, uncle, grandParent) {\n      uncle.flipColor();\n      parent.flipColor();\n      grandParent.flipColor();\n      this._recolorAndRotate(grandParent);\n  }\n\n  _rotateRight(node) {\n      const leftNode = node.left;\n      node.left = leftNode.right;\n\n      if (node.left !== null) {\n          node.left.parent = node;\n      }\n\n      leftNode.right = node;\n      leftNode.parent = node.parent;\n      this._updateChildrenOfParentNode(node, leftNode);\n      node.parent = leftNode;\n  }\n\n  _rotateLeft(node) {\n      const rightNode = node.right;\n      node.right = rightNode.left;\n\n      if (node.right !== null) {\n          node.right.parent = node;\n      }\n\n      rightNode.left = node;\n      rightNode.parent = node.parent;\n      this._updateChildrenOfParentNode(node, rightNode);\n      node.parent = rightNode;\n  }\n\n  _updateChildrenOfParentNode(node, tempNode) {\n      if (node.parent === null) {\n          this.root = tempNode;\n      } else if (node.isLeftChild()) {\n          node.parent.left = tempNode;\n      } else {\n          node.parent.right = tempNode;\n      }\n  }\n\n  traverse() {\n      this._traverseInOrder(this.root);\n  }\n\n  _traverseInOrder(node) {\n      if (node !== null) {\n          this._traverseInOrder(node.left);\n          console.log(node.data);\n          this._traverseInOrder(node.right);\n      }\n  }\n\n  getMax() {\n      if (this.isEmpty()) {\n          return null;\n      }\n      return this._getMax(this.root);\n  }\n\n  _getMax(node) {\n      if (node.right !== null) {\n          return this._getMax(node.right);\n      }\n      return node.data;\n  }\n\n  getMin() {\n      if (this.isEmpty()) {\n          return null;\n      }\n      return this._getMin(this.root);\n  }\n\n  _getMin(node) {\n      if (node.left !== null) {\n          return this._getMin(node.left);\n      }\n      return node.data;\n  }\n\n  isEmpty() {\n      return this.root === null;\n  }\n}\nexport default RedBlackTree;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
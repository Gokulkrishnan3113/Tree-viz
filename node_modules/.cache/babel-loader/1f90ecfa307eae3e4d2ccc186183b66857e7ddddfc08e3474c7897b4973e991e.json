{"ast":null,"code":"import _classPrivateFieldLooseKey from \"/Users/gokulkrishnan/College/project/treeviz/node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseKey.js\";\nimport BinarySearchTree from \"../BST/js_binary_search_tree\";\nconst COLOR = Object.freeze({\n  RED: 'red',\n  BLACK: 'black'\n});\nclass RedBlackNode {\n  constructor(key = null, parent = null) {\n    this.left = null;\n    this.right = null;\n    this.key = key;\n    this.parent = parent;\n    if (key == null) {\n      this.color = COLOR.BLACK;\n    } else {\n      this.color = COLOR.RED;\n      this.left = new RedBlackNode(null, this);\n      this.right = new RedBlackNode(null, this);\n    }\n  }\n  get isRed() {\n    return this.color === COLOR.RED;\n  }\n  get isBlack() {\n    return !this.isRed;\n  }\n  get isNil() {\n    return this.key === null;\n  }\n  get color() {\n    return this.color;\n  }\n  set color(newColor) {\n    if (!this.isNil) {\n      this.color = newColor;\n    }\n  }\n}\nvar _root = /*#__PURE__*/_classPrivateFieldLooseKey(\"root\");\nclass RBTREE extends BinarySearchTree {\n  constructor(compareFn = null) {\n    let fn = null;\n    if (compareFn && typeof compareFn === 'function') {\n      fn = compareFn;\n    } else {\n      fn = (a, b) => {\n        if (a > b) return BinarySearchTree.defaultCompareNumberFn.BIGGER;\n        if (a < b) return BinarySearchTree.defaultCompareNumberFn.SMALLER;\n        return BinarySearchTree.defaultCompareNumberFn.EQUAL;\n      };\n    }\n    super(fn);\n    Object.defineProperty(this, _root, {\n      writable: true,\n      value: null\n    });\n    this.insertNode = (newNode, currentNode = this.root) => {\n      if (this.compare(newNode.key, currentNode.key) === BinarySearchTree.comparison.SMALLER) {\n        if (currentNode.left.isNil) {\n          currentNode.left = newNode;\n          newNode.parent = currentNode;\n        } else {\n          this.insertNode(newNode, currentNode.left);\n        }\n      } else {\n        if (currentNode.right.isNil) {\n          currentNode.right = newNode;\n          newNode.parent = currentNode;\n        } else {\n          this.insertNode(newNode, currentNode.right);\n        }\n      }\n    };\n    this.RRotation = node => {\n      if (node.left) {\n        // console.log('r rotate', node.key);\n        const nodeParent = node.parent;\n        const detached = node.left;\n        node.left = detached.right;\n        detached.right = node;\n        node.parent = detached;\n        if (node.left !== null) {\n          node.left.parent = node;\n        }\n        if (nodeParent !== null) {\n          if (node === nodeParent.left) {\n            nodeParent.left = detached;\n          } else {\n            nodeParent.right = detached;\n          }\n        } else {\n          this.root = detached;\n        }\n        detached.parent = nodeParent;\n      }\n    };\n    this.LRotation = node => {\n      if (node.right) {\n        // console.log('l rotate', node.key);\n        const nodeParent = node.parent;\n        const detached = node.right;\n        node.right = detached.left;\n        detached.left = node;\n        node.parent = detached;\n        if (node.right !== null) {\n          node.right.parent = node;\n        }\n        if (nodeParent !== null) {\n          if (node === nodeParent.left) {\n            nodeParent.left = detached;\n          } else {\n            nodeParent.right = detached;\n          }\n        } else {\n          this.root = detached;\n        }\n        detached.parent = nodeParent;\n      }\n    };\n    this.removeNode = (key, node = this.root) => {\n      if (node === null || node.isNil) return;\n      if (this.compare(key, node.key) === BinarySearchTree.comparison.SMALLER) {\n        this.removeNode(key, node.left);\n      } else if (this.compare(key, node.key) === BinarySearchTree.comparison.BIGGER) {\n        this.removeNode(key, node.right);\n      } else if (node.left.isNil && node.right.isNil) {\n        // console.log('remove 1', node.key)\n        this.handleRemovedNode(node);\n        if (node.parent === null) {\n          this.root = null;\n        } else if (node === node.parent.left) {\n          node.parent.left = this.createNode(null, node);\n        } else {\n          node.parent.right = this.createNode(null, node);\n        }\n      } else if (node.left.isNil) {\n        // console.log('remove 2', node.key)\n        node.key = node.right.key;\n        node.right = this.createNode(null, node);\n      } else if (node.right.isNil) {\n        // console.log('remove 3', node.key)\n        node.key = node.left.key;\n        node.left = this.createNode(null, node);\n      } else {\n        const max = this.maxNode(node.left);\n        // console.log('remove 4', node.key)\n        node.key = max.key;\n        this.removeNode(max.key, node.left);\n      }\n    };\n    this.maxNode = node => {\n      while (node && !node.isNill && !node.right.isNil) {\n        node = node.right;\n      }\n      return node;\n    };\n    this.compare = fn;\n  }\n  get root() {\n    return this.root;\n  }\n  createNode(key = null, parent = null) {\n    return new RedBlackNode(key, parent);\n  }\n  insertrb(key) {\n    const newNode = this.createNode(key);\n    if (this.root === null) {\n      this.root = newNode;\n    } else {\n      this.insertNode(newNode);\n    }\n    this.adjustTreeAfterInsertion(newNode);\n  }\n  adjustTreeAfterInsertion(node) {\n    if (node.parent === null) {\n      node.color = COLOR.BLACK;\n    } else if (node.parent.isRed) {\n      const parentNode = node.parent;\n      const grandParentNode = parentNode.parent;\n      const uncleNode = grandParentNode.left === parentNode ? grandParentNode.right : grandParentNode.left;\n      if (uncleNode.isBlack) {\n        // console.log('red parent blk uncle')\n        this.handleBlackUncle(node);\n      } else {\n        // console.log('red parent red uncle')\n        this.handleRedUncle(parentNode, uncleNode, grandParentNode);\n      }\n    }\n  }\n  handleBlackUncle(node) {\n    const parentNode = node.parent;\n    if (node === parentNode.left) {\n      if (parentNode === parentNode.parent.left) {\n        this.recolorMidNode(parentNode);\n        this.RRotation(parentNode.parent);\n      } else {\n        this.RRotation(parentNode);\n        this.recolorMidNode(node);\n        this.LRotation(node.parent);\n      }\n    } else {\n      if (parentNode === parentNode.parent.right) {\n        this.recolorMidNode(parentNode);\n        this.LRotation(parentNode.parent);\n      } else {\n        this.LRotation(parentNode);\n        this.recolorMidNode(node);\n        this.RRotation(node.parent);\n      }\n    }\n  }\n  handleRedUncle(parentNode, uncleNode, grandParentNode) {\n    parentNode.color = COLOR.BLACK;\n    uncleNode.color = COLOR.BLACK;\n    grandParentNode.color = COLOR.RED;\n    this.adjustTreeAfterInsertion(grandParentNode);\n  }\n  recolorMidNode(node) {\n    node.color = COLOR.BLACK;\n    node.parent.color = COLOR.RED;\n  }\n  removerb(key) {\n    this.removeNode(key);\n  }\n  getNodeSibling(node) {\n    const parentNode = node.parent;\n    const sibNode = parentNode.left === node ? parentNode.right : parentNode.left;\n    return sibNode;\n  }\n  handleCase2(node) {\n    // sibling is red with 2 black children\n    const sibNode = this.getNodeSibling(node);\n    if (sibNode.isRed) {\n      const parentNode = node.parent;\n      sibNode.color = COLOR.BLACK;\n      parentNode.color = COLOR.RED;\n      if (node === parentNode.left) {\n        this.LRotation(parentNode);\n      } else {\n        this.RRotation(parentNode);\n      }\n    }\n    this.handleCase3(node);\n  }\n  handleCase3(node) {\n    // node parent is black, sibling and its children are black\n    const sibNode = this.getNodeSibling(node);\n    if (node.parent.isBlack && sibNode.isBlack && sibNode.left.isBlack && sibNode.right.isBlack) {\n      sibNode.color = COLOR.RED;\n      this.handleRemovedNode(node.parent);\n    } else {\n      this.handleCase4(node);\n    }\n  }\n  handleCase4(node) {\n    // node parent is red, sibling and its children are black\n    const sibNode = this.getNodeSibling(node);\n    if (node.parent.isRed && sibNode.isBlack && sibNode.left.isBlack && sibNode.right.isBlack) {\n      sibNode.color = COLOR.RED;\n      node.parent.color = COLOR.BLACK;\n    } else {\n      this.handleCase5(node);\n    }\n  }\n  handleCase5(node) {\n    // sib is black with red left and black right\n    const sibNode = this.getNodeSibling(node);\n    if (sibNode.isBlack) {\n      const parentNode = node.parent;\n      if (node === parentNode.left && sibNode.left.isRed && sibNode.right.isBlack) {\n        sibNode.color = COLOR.RED;\n        sibNode.left.color = COLOR.BLACK;\n        this.RRotation(sibNode);\n      }\n      if (node === parentNode.right && sibNode.left.isBlack && sibNode.right.isRed) {\n        sibNode.color = COLOR.RED;\n        sibNode.right.color = COLOR.BLACK;\n        this.LRotation(sibNode);\n      }\n    }\n    this.handleCase6(node);\n  }\n  handleCase6(node) {\n    // sib is black with red right and black left\n    const sibNode = this.getNodeSibling(node);\n    const parentNode = node.parent;\n    sibNode.color = parentNode.color;\n    parentNode.color = COLOR.BLACK;\n    if (node === parentNode.left) {\n      sibNode.right.color = COLOR.BLACK;\n      this.LRotation(parentNode);\n    } else {\n      sibNode.left.color = COLOR.BLACK;\n      this.RRotation(parentNode);\n    }\n  }\n  handleRemovedNode(node) {\n    // console.log('case 1', node.key);\n    // node is black and with a parent\n    if (node.isBlack && node.parent !== null) {\n      // case 1\n      this.handleCase2(node);\n    }\n  }\n}\nexport default RBTREE;","map":{"version":3,"names":["BinarySearchTree","COLOR","Object","freeze","RED","BLACK","RedBlackNode","constructor","key","parent","left","right","color","isRed","isBlack","isNil","newColor","_root","_classPrivateFieldLooseKey","RBTREE","compareFn","fn","a","b","defaultCompareNumberFn","BIGGER","SMALLER","EQUAL","defineProperty","writable","value","insertNode","newNode","currentNode","root","compare","comparison","RRotation","node","nodeParent","detached","LRotation","removeNode","handleRemovedNode","createNode","max","maxNode","isNill","insertrb","adjustTreeAfterInsertion","parentNode","grandParentNode","uncleNode","handleBlackUncle","handleRedUncle","recolorMidNode","removerb","getNodeSibling","sibNode","handleCase2","handleCase3","handleCase4","handleCase5","handleCase6"],"sources":["/Users/gokulkrishnan/College/project/treeviz/src/RB/rb.js"],"sourcesContent":["import BinarySearchTree from \"../BST/js_binary_search_tree\";\nconst COLOR = Object.freeze({\n    RED: 'red',\n    BLACK: 'black'\n  })\n\n  class RedBlackNode {\n    color;\n    left = null;\n    right = null;\n    constructor(key = null, parent = null) {\n        this.key = key;\n        this.parent = parent;\n        \n        if(key == null) {\n          this.color = COLOR.BLACK;\n        } else {\n          this.color = COLOR.RED;\n          this.left = new RedBlackNode(null, this);\n          this.right = new RedBlackNode(null, this);\n        }\n      }\n      get isRed() {\n        return this.color === COLOR.RED;\n      }\n      \n      get isBlack() {\n        return !this.isRed\n      }\n      \n      get isNil() {\n        return this.key === null;\n      }\n      \n      get color() {\n        return this.color;\n      }\n      \n      set color(newColor) {\n        if(!this.isNil) {\n           this.color = newColor;\n        }\n      }\n    \n  }\n\n  class RBTREE extends BinarySearchTree{\n    #root = null;\n    compare;\n    \n    constructor(compareFn = null) {\n      let fn = null;\n      \n      if(compareFn && typeof compareFn === 'function') {\n        fn = compareFn;\n      } else {\n        fn = (a, b) => {\n          if(a > b) return BinarySearchTree.defaultCompareNumberFn.BIGGER;\n          if(a < b) return BinarySearchTree.defaultCompareNumberFn.SMALLER;\n        \n          return BinarySearchTree.defaultCompareNumberFn.EQUAL;\n        }\n      }\n  \n      super(fn);\n      this.compare = fn;\n    }\n    get root() {\n        return this.root;\n      }\n      \n      createNode(key = null, parent = null) {\n        return new RedBlackNode(key, parent);\n      }\n      \n      insertrb(key) {\n        const newNode = this.createNode(key);\n        \n        if(this.root === null) {\n          this.root = newNode;\n        } else {\n          this.insertNode(newNode);\n        }\n        \n        this.adjustTreeAfterInsertion(newNode);\n      }\n\n      insertNode = (newNode, currentNode = this.root) => {\n        if(this.compare(newNode.key, currentNode.key) === BinarySearchTree.comparison.SMALLER) {\n           if(currentNode.left.isNil) {\n             currentNode.left = newNode;\n             newNode.parent = currentNode;\n           } else {\n            this.insertNode(newNode, currentNode.left)\n          }                            \n        } else {\n           if(currentNode.right.isNil) {\n             currentNode.right = newNode;\n             newNode.parent = currentNode;\n           } else {\n             this.insertNode(newNode, currentNode.right)\n           }  \n        }\n      }\n\n      adjustTreeAfterInsertion(node) {\n        if(node.parent === null) {\n          node.color = COLOR.BLACK;\n        } else if(node.parent.isRed) {\n          const parentNode = node.parent;\n          const grandParentNode = parentNode.parent;\n          const uncleNode = grandParentNode.left === parentNode\n            ? grandParentNode.right\n            : grandParentNode.left;\n          \n          if(uncleNode.isBlack) {\n            // console.log('red parent blk uncle')\n            this.handleBlackUncle(node);\n          } else {\n            // console.log('red parent red uncle')\n            this.handleRedUncle(parentNode, uncleNode, grandParentNode)\n          }\n        }\n      }\n\n      handleBlackUncle(node) {\n        const parentNode = node.parent;\n        \n        if(node === parentNode.left) {\n          if(parentNode === parentNode.parent.left) {\n            this.recolorMidNode(parentNode);\n            this.RRotation(parentNode.parent);\n          } else {\n            this.RRotation(parentNode);\n            this.recolorMidNode(node);\n            this.LRotation(node.parent);\n          }\n        } else {\n          if(parentNode === parentNode.parent.right) {\n            this.recolorMidNode(parentNode);\n            this.LRotation(parentNode.parent);\n          } else {\n            this.LRotation(parentNode);\n            this.recolorMidNode(node);\n            this.RRotation(node.parent);\n          }\n        }\n      }\n\n      RRotation = (node) => {\n        if(node.left) {\n          // console.log('r rotate', node.key);\n          const nodeParent = node.parent;\n          const detached = node.left;\n          node.left = detached.right;\n          detached.right = node;\n          node.parent = detached;\n          \n          if(node.left !== null) {\n            node.left.parent = node;\n          }\n          \n          if(nodeParent !== null) {\n            if(node === nodeParent.left) {\n              nodeParent.left = detached;\n            } else {\n              nodeParent.right = detached;\n            }\n          } else {\n            this.root = detached;\n          }\n          \n          detached.parent = nodeParent;\n        }\n      }\n      \n      LRotation = (node) => {\n        if(node.right) {\n          // console.log('l rotate', node.key);\n          const nodeParent = node.parent;\n          const detached = node.right;\n          node.right = detached.left;\n          detached.left = node;\n          node.parent = detached;\n          \n          if(node.right !== null) {\n            node.right.parent = node;\n          }\n          \n          if(nodeParent !== null) {\n            if(node === nodeParent.left) {\n              nodeParent.left = detached;\n            } else {\n              nodeParent.right = detached;\n            }\n          } else {\n            this.root = detached;\n          }\n          \n          detached.parent = nodeParent;\n        }\n      }\n\n\n      handleRedUncle(parentNode, uncleNode, grandParentNode) {\n        parentNode.color = COLOR.BLACK;\n        uncleNode.color = COLOR.BLACK;\n        grandParentNode.color = COLOR.RED;\n        this.adjustTreeAfterInsertion(grandParentNode);\n      }\n\n      recolorMidNode(node) {\n        node.color = COLOR.BLACK;\n        node.parent.color = COLOR.RED;\n      }\n\n\n\n\n      removerb(key) {\n        this.removeNode(key);\n      }\n\n      removeNode = (key, node = this.root) => {\n        if(node === null || node.isNil) return;\n    \n        if(this.compare(key, node.key) === BinarySearchTree.comparison.SMALLER) {\n          this.removeNode(key, node.left);\n        } else if(this.compare(key, node.key) === BinarySearchTree.comparison.BIGGER) {\n          this.removeNode(key, node.right);\n        } else if(node.left.isNil && node.right.isNil) {\n          // console.log('remove 1', node.key)\n          this.handleRemovedNode(node);\n          \n          if(node.parent === null) {\n            this.root = null;\n          } else if(node === node.parent.left) {\n            node.parent.left = this.createNode(null, node);\n          } else {\n            node.parent.right = this.createNode(null, node);\n          }\n        } else if(node.left.isNil) {\n          // console.log('remove 2', node.key)\n          node.key = node.right.key;\n          node.right = this.createNode(null, node);\n        } else if(node.right.isNil) {\n          // console.log('remove 3', node.key)\n          node.key = node.left.key;\n          node.left = this.createNode(null, node);\n        } else {\n          const max = this.maxNode(node.left);\n          // console.log('remove 4', node.key)\n          node.key = max.key;\n          this.removeNode(max.key, node.left);\n        }\n      }\n      maxNode = (node) => {\n        while(node && !node.isNill && !node.right.isNil) {\n          node = node.right;\n        }\n    \n        return node;\n      }\n\n      getNodeSibling(node) {\n        const parentNode = node.parent;\n        const sibNode = parentNode.left === node\n          ? parentNode.right\n          : parentNode.left;\n        \n        return sibNode;\n      }\n\n      handleCase2(node) {\n        // sibling is red with 2 black children\n        const sibNode = this.getNodeSibling(node);\n    \n        if(sibNode.isRed) {\n          const parentNode = node.parent;\n        \n          sibNode.color = COLOR.BLACK;\n          parentNode.color = COLOR.RED;\n    \n          if(node === parentNode.left) {\n            this.LRotation(parentNode);\n          } else {\n            this.RRotation(parentNode);\n          }\n        }\n        \n        this.handleCase3(node);\n      }\n      \n      handleCase3(node) {\n        // node parent is black, sibling and its children are black\n        const sibNode = this.getNodeSibling(node);\n        \n        if(\n          node.parent.isBlack && \n          sibNode.isBlack && \n          sibNode.left.isBlack && \n          sibNode.right.isBlack\n        ) {\n          sibNode.color = COLOR.RED;\n          this.handleRemovedNode(node.parent);\n        } else {\n          this.handleCase4(node);\n        }\n      }\n      \n      handleCase4(node) {\n        // node parent is red, sibling and its children are black\n        const sibNode = this.getNodeSibling(node);\n        \n        if(\n          node.parent.isRed && \n          sibNode.isBlack && \n          sibNode.left.isBlack && \n          sibNode.right.isBlack\n        ) {\n          sibNode.color = COLOR.RED;\n          node.parent.color = COLOR.BLACK;\n        } else {\n          this.handleCase5(node);\n        }\n      }\n      \n      handleCase5(node) {\n        // sib is black with red left and black right\n        const sibNode = this.getNodeSibling(node);\n        \n        if(sibNode.isBlack) {\n          const parentNode = node.parent;\n        \n          if(node === parentNode.left && sibNode.left.isRed && sibNode.right.isBlack) {\n            sibNode.color = COLOR.RED;\n            sibNode.left.color = COLOR.BLACK;\n            this.RRotation(sibNode);\n          }\n    \n          if(node === parentNode.right && sibNode.left.isBlack && sibNode.right.isRed) {\n            sibNode.color = COLOR.RED;\n            sibNode.right.color = COLOR.BLACK;\n            this.LRotation(sibNode);\n          }\n        }\n       \n        this.handleCase6(node);\n      }\n      \n      handleCase6(node) {\n        // sib is black with red right and black left\n        const sibNode = this.getNodeSibling(node);\n        const parentNode = node.parent;\n          \n        sibNode.color = parentNode.color;\n        parentNode.color = COLOR.BLACK;\n    \n        if(node === parentNode.left) {\n          sibNode.right.color = COLOR.BLACK;\n          this.LRotation(parentNode);\n        } else {\n          sibNode.left.color = COLOR.BLACK;\n          this.RRotation(parentNode);\n        }\n      }\n      \n      handleRemovedNode(node) {\n        // console.log('case 1', node.key);\n        // node is black and with a parent\n        if(node.isBlack && node.parent !== null) {// case 1\n          this.handleCase2(node);\n        }\n      }\n      \n\n  }\nexport default RBTREE;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import _classPrivateFieldLooseBase from \"/Users/gokulkrishnan/College/project/treeviz/node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseBase.js\";\nimport _classPrivateFieldLooseKey from \"/Users/gokulkrishnan/College/project/treeviz/node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseKey.js\";\nimport BinarySearchTree from \"../BST/js_binary_search_tree\";\nconst COLOR = Object.freeze({\n  RED: 'red',\n  BLACK: 'black'\n});\nvar _color = /*#__PURE__*/_classPrivateFieldLooseKey(\"color\");\nclass RedBlackNode {\n  constructor(key = null, parent = null) {\n    Object.defineProperty(this, _color, {\n      writable: true,\n      value: void 0\n    });\n    this.left = null;\n    this.right = null;\n    this.key = key;\n    this.parent = parent;\n    if (key == null) {\n      _classPrivateFieldLooseBase(this, _color)[_color] = COLOR.BLACK;\n    } else {\n      _classPrivateFieldLooseBase(this, _color)[_color] = COLOR.RED;\n      this.left = new RedBlackNode(null, this);\n      this.right = new RedBlackNode(null, this);\n    }\n  }\n  get isRed() {\n    return _classPrivateFieldLooseBase(this, _color)[_color] === COLOR.RED;\n  }\n  get isBlack() {\n    return !this.isRed;\n  }\n  get isNil() {\n    return this.key === null;\n  }\n  get color() {\n    return _classPrivateFieldLooseBase(this, _color)[_color];\n  }\n  set color(newColor) {\n    if (!this.isNil) {\n      _classPrivateFieldLooseBase(this, _color)[_color] = newColor;\n    }\n  }\n}\nvar _root = /*#__PURE__*/_classPrivateFieldLooseKey(\"root\");\nclass RBTREE extends BinarySearchTree {\n  constructor(compareFn = null) {\n    let fn = null;\n    if (compareFn && typeof compareFn === 'function') {\n      fn = compareFn;\n    } else {\n      fn = (a, b) => {\n        if (a > b) return BinarySearchTree.defaultCompareNumberFn.BIGGER;\n        if (a < b) return BinarySearchTree.defaultCompareNumberFn.SMALLER;\n        return BinarySearchTree.defaultCompareNumberFn.EQUAL;\n      };\n    }\n    super(fn);\n    Object.defineProperty(this, _root, {\n      writable: true,\n      value: null\n    });\n    this.insertNode = (newNode, currentNode = _classPrivateFieldLooseBase(this, _root)[_root]) => {\n      if (this.compare(newNode.key, currentNode.key) === BinarySearchTree.comparison.SMALLER) {\n        if (currentNode.left.isNil) {\n          currentNode.left = newNode;\n          newNode.parent = currentNode;\n        } else {\n          this.insertNode(newNode, currentNode.left);\n        }\n      } else {\n        if (currentNode.right.isNil) {\n          currentNode.right = newNode;\n          newNode.parent = currentNode;\n        } else {\n          this.insertNode(newNode, currentNode.right);\n        }\n      }\n    };\n    this.RRotation = node => {\n      if (node.left) {\n        // console.log('r rotate', node.key);\n        const nodeParent = node.parent;\n        const detached = node.left;\n        node.left = detached.right;\n        detached.right = node;\n        node.parent = detached;\n        if (node.left !== null) {\n          node.left.parent = node;\n        }\n        if (nodeParent !== null) {\n          if (node === nodeParent.left) {\n            nodeParent.left = detached;\n          } else {\n            nodeParent.right = detached;\n          }\n        } else {\n          _classPrivateFieldLooseBase(this, _root)[_root] = detached;\n        }\n        detached.parent = nodeParent;\n      }\n    };\n    this.LRotation = node => {\n      if (node.right) {\n        // console.log('l rotate', node.key);\n        const nodeParent = node.parent;\n        const detached = node.right;\n        node.right = detached.left;\n        detached.left = node;\n        node.parent = detached;\n        if (node.right !== null) {\n          node.right.parent = node;\n        }\n        if (nodeParent !== null) {\n          if (node === nodeParent.left) {\n            nodeParent.left = detached;\n          } else {\n            nodeParent.right = detached;\n          }\n        } else {\n          _classPrivateFieldLooseBase(this, _root)[_root] = detached;\n        }\n        detached.parent = nodeParent;\n      }\n    };\n    this.removeNode = (key, node = _classPrivateFieldLooseBase(this, _root)[_root]) => {\n      if (node === null || node.isNil) return;\n      if (this.compare(key, node.key) === BinarySearchTree.comparison.SMALLER) {\n        this.removeNode(key, node.left);\n      } else if (this.compare(key, node.key) === BinarySearchTree.comparison.BIGGER) {\n        this.removeNode(key, node.right);\n      } else if (node.left.isNil && node.right.isNil) {\n        // console.log('remove 1', node.key)\n        this.handleRemovedNode(node);\n        if (node.parent === null) {\n          _classPrivateFieldLooseBase(this, _root)[_root] = null;\n        } else if (node === node.parent.left) {\n          node.parent.left = this.createNode(null, node);\n        } else {\n          node.parent.right = this.createNode(null, node);\n        }\n      } else if (node.left.isNil) {\n        // console.log('remove 2', node.key)\n        node.key = node.right.key;\n        node.right = this.createNode(null, node);\n      } else if (node.right.isNil) {\n        // console.log('remove 3', node.key)\n        node.key = node.left.key;\n        node.left = this.createNode(null, node);\n      } else {\n        const max = this.maxNode(node.left);\n        // console.log('remove 4', node.key)\n        node.key = max.key;\n        this.removeNode(max.key, node.left);\n      }\n    };\n    this.maxNode = node => {\n      while (node && !node.isNill && !node.right.isNil) {\n        node = node.right;\n      }\n      return node;\n    };\n    this.compare = fn;\n    _classPrivateFieldLooseBase(this, _root)[_root] = this.createNode(null);\n  }\n  get root() {\n    return _classPrivateFieldLooseBase(this, _root)[_root];\n  }\n  createNode(key = null, parent = null) {\n    return new RedBlackNode(key, parent);\n  }\n  createRoot() {\n    return this.createNode(null);\n  }\n  insertrb(key) {\n    const newNode = this.createNode(key);\n    if (_classPrivateFieldLooseBase(this, _root)[_root] === null) {\n      _classPrivateFieldLooseBase(this, _root)[_root] = this.createRoot();\n    }\n    this.insertNode(newNode);\n    this.adjustTreeAfterInsertion(newNode);\n  }\n  adjustTreeAfterInsertion(node) {\n    if (node.parent === null) {\n      node.color = COLOR.BLACK;\n    } else if (node.parent.isRed) {\n      const parentNode = node.parent;\n      const grandParentNode = parentNode.parent;\n      const uncleNode = grandParentNode.left === parentNode ? grandParentNode.right : grandParentNode.left;\n      if (uncleNode.isBlack) {\n        // console.log('red parent blk uncle')\n        this.handleBlackUncle(node);\n      } else {\n        // console.log('red parent red uncle')\n        this.handleRedUncle(parentNode, uncleNode, grandParentNode);\n      }\n    }\n  }\n  handleBlackUncle(node) {\n    const parentNode = node.parent;\n    if (node === parentNode.left) {\n      if (parentNode === parentNode.parent.left) {\n        this.recolorMidNode(parentNode);\n        this.RRotation(parentNode.parent);\n      } else {\n        this.RRotation(parentNode);\n        this.recolorMidNode(node);\n        this.LRotation(node.parent);\n      }\n    } else {\n      if (parentNode === parentNode.parent.right) {\n        this.recolorMidNode(parentNode);\n        this.LRotation(parentNode.parent);\n      } else {\n        this.LRotation(parentNode);\n        this.recolorMidNode(node);\n        this.RRotation(node.parent);\n      }\n    }\n  }\n  handleRedUncle(parentNode, uncleNode, grandParentNode) {\n    parentNode.color = COLOR.BLACK;\n    uncleNode.color = COLOR.BLACK;\n    grandParentNode.color = COLOR.RED;\n    this.adjustTreeAfterInsertion(grandParentNode);\n  }\n  recolorMidNode(node) {\n    node.color = COLOR.BLACK;\n    node.parent.color = COLOR.RED;\n  }\n  removerb(key) {\n    this.removeNode(key);\n  }\n  getNodeSibling(node) {\n    const parentNode = node.parent;\n    const sibNode = parentNode.left === node ? parentNode.right : parentNode.left;\n    return sibNode;\n  }\n  handleCase2(node) {\n    // sibling is red with 2 black children\n    const sibNode = this.getNodeSibling(node);\n    if (sibNode.isRed) {\n      const parentNode = node.parent;\n      sibNode.color = COLOR.BLACK;\n      parentNode.color = COLOR.RED;\n      if (node === parentNode.left) {\n        this.LRotation(parentNode);\n      } else {\n        this.RRotation(parentNode);\n      }\n    }\n    this.handleCase3(node);\n  }\n  handleCase3(node) {\n    // node parent is black, sibling and its children are black\n    const sibNode = this.getNodeSibling(node);\n    if (node.parent.isBlack && sibNode.isBlack && sibNode.left.isBlack && sibNode.right.isBlack) {\n      sibNode.color = COLOR.RED;\n      this.handleRemovedNode(node.parent);\n    } else {\n      this.handleCase4(node);\n    }\n  }\n  handleCase4(node) {\n    // node parent is red, sibling and its children are black\n    const sibNode = this.getNodeSibling(node);\n    if (node.parent.isRed && sibNode.isBlack && sibNode.left.isBlack && sibNode.right.isBlack) {\n      sibNode.color = COLOR.RED;\n      node.parent.color = COLOR.BLACK;\n    } else {\n      this.handleCase5(node);\n    }\n  }\n  handleCase5(node) {\n    // sib is black with red left and black right\n    const sibNode = this.getNodeSibling(node);\n    if (sibNode.isBlack) {\n      const parentNode = node.parent;\n      if (node === parentNode.left && sibNode.left.isRed && sibNode.right.isBlack) {\n        sibNode.color = COLOR.RED;\n        sibNode.left.color = COLOR.BLACK;\n        this.RRotation(sibNode);\n      }\n      if (node === parentNode.right && sibNode.left.isBlack && sibNode.right.isRed) {\n        sibNode.color = COLOR.RED;\n        sibNode.right.color = COLOR.BLACK;\n        this.LRotation(sibNode);\n      }\n    }\n    this.handleCase6(node);\n  }\n  handleCase6(node) {\n    // sib is black with red right and black left\n    const sibNode = this.getNodeSibling(node);\n    const parentNode = node.parent;\n    sibNode.color = parentNode.color;\n    parentNode.color = COLOR.BLACK;\n    if (node === parentNode.left) {\n      sibNode.right.color = COLOR.BLACK;\n      this.LRotation(parentNode);\n    } else {\n      sibNode.left.color = COLOR.BLACK;\n      this.RRotation(parentNode);\n    }\n  }\n  handleRemovedNode(node) {\n    // console.log('case 1', node.key);\n    // node is black and with a parent\n    if (node.isBlack && node.parent !== null) {\n      // case 1\n      this.handleCase2(node);\n    }\n  }\n}\nexport default RBTREE;","map":{"version":3,"names":["BinarySearchTree","COLOR","Object","freeze","RED","BLACK","_color","_classPrivateFieldLooseKey","RedBlackNode","constructor","key","parent","defineProperty","writable","value","left","right","_classPrivateFieldLooseBase","isRed","isBlack","isNil","color","newColor","_root","RBTREE","compareFn","fn","a","b","defaultCompareNumberFn","BIGGER","SMALLER","EQUAL","insertNode","newNode","currentNode","compare","comparison","RRotation","node","nodeParent","detached","LRotation","removeNode","handleRemovedNode","createNode","max","maxNode","isNill","root","createRoot","insertrb","adjustTreeAfterInsertion","parentNode","grandParentNode","uncleNode","handleBlackUncle","handleRedUncle","recolorMidNode","removerb","getNodeSibling","sibNode","handleCase2","handleCase3","handleCase4","handleCase5","handleCase6"],"sources":["/Users/gokulkrishnan/College/project/treeviz/src/RB/rb.js"],"sourcesContent":["import BinarySearchTree from \"../BST/js_binary_search_tree\";\nconst COLOR = Object.freeze({\n    RED: 'red',\n    BLACK: 'black'\n  })\n\n  class RedBlackNode {\n    \n    #color;\n    left = null;\n    right = null;\n    constructor(key = null, parent = null) {\n        this.key = key;\n        this.parent = parent;\n        \n        if(key == null) {\n          this.#color = COLOR.BLACK;\n        } else {\n          this.#color = COLOR.RED;\n          this.left = new RedBlackNode(null, this);\n          this.right = new RedBlackNode(null, this);\n        }\n      }\n      get isRed() {\n        return this.#color === COLOR.RED;\n      }\n      \n      get isBlack() {\n        return !this.isRed\n      }\n      \n      get isNil() {\n        return this.key === null;\n      }\n      \n      get color() {\n        return this.#color;\n      }\n      \n      set color(newColor) {\n        if(!this.isNil) {\n           this.#color = newColor;\n        }\n      }\n    \n  }\n\n  class RBTREE extends BinarySearchTree{\n    #root = null;\n    compare;\n    \n    constructor(compareFn = null) {\n      let fn = null;\n      \n      if(compareFn && typeof compareFn === 'function') {\n        fn = compareFn;\n      } else {\n        fn = (a, b) => {\n          if(a > b) return BinarySearchTree.defaultCompareNumberFn.BIGGER;\n          if(a < b) return BinarySearchTree.defaultCompareNumberFn.SMALLER;\n        \n          return BinarySearchTree.defaultCompareNumberFn.EQUAL;\n        }\n      }\n  \n      super(fn);\n      this.compare = fn;\n      this.#root = this.createNode(null);\n    }\n    get root() {\n        return this.#root;\n      }\n      \n      createNode(key = null, parent = null) {\n        return new RedBlackNode(key, parent);\n      }\n      createRoot() {\n        return this.createNode(null);\n      }\n\n      insertrb(key) {\n      const newNode = this.createNode(key);\n\n      if (this.#root === null) {\n      this.#root = this.createRoot();\n      }\n\n      this.insertNode(newNode);\n      this.adjustTreeAfterInsertion(newNode);\n      }\n\n      insertNode = (newNode, currentNode = this.#root) => {\n        if(this.compare(newNode.key, currentNode.key) === BinarySearchTree.comparison.SMALLER) {\n           if(currentNode.left.isNil) {\n             currentNode.left = newNode;\n             newNode.parent = currentNode;\n           } else {\n            this.insertNode(newNode, currentNode.left)\n          }                            \n        } else {\n           if(currentNode.right.isNil) {\n             currentNode.right = newNode;\n             newNode.parent = currentNode;\n           } else {\n             this.insertNode(newNode, currentNode.right)\n           }  \n        }\n      }\n\n      adjustTreeAfterInsertion(node) {\n        if(node.parent === null) {\n          node.color = COLOR.BLACK;\n        } else if(node.parent.isRed) {\n          const parentNode = node.parent;\n          const grandParentNode = parentNode.parent;\n          const uncleNode = grandParentNode.left === parentNode\n            ? grandParentNode.right\n            : grandParentNode.left;\n          \n          if(uncleNode.isBlack) {\n            // console.log('red parent blk uncle')\n            this.handleBlackUncle(node);\n          } else {\n            // console.log('red parent red uncle')\n            this.handleRedUncle(parentNode, uncleNode, grandParentNode)\n          }\n        }\n      }\n\n      handleBlackUncle(node) {\n        const parentNode = node.parent;\n        \n        if(node === parentNode.left) {\n          if(parentNode === parentNode.parent.left) {\n            this.recolorMidNode(parentNode);\n            this.RRotation(parentNode.parent);\n          } else {\n            this.RRotation(parentNode);\n            this.recolorMidNode(node);\n            this.LRotation(node.parent);\n          }\n        } else {\n          if(parentNode === parentNode.parent.right) {\n            this.recolorMidNode(parentNode);\n            this.LRotation(parentNode.parent);\n          } else {\n            this.LRotation(parentNode);\n            this.recolorMidNode(node);\n            this.RRotation(node.parent);\n          }\n        }\n      }\n\n      RRotation = (node) => {\n        if(node.left) {\n          // console.log('r rotate', node.key);\n          const nodeParent = node.parent;\n          const detached = node.left;\n          node.left = detached.right;\n          detached.right = node;\n          node.parent = detached;\n          \n          if(node.left !== null) {\n            node.left.parent = node;\n          }\n          \n          if(nodeParent !== null) {\n            if(node === nodeParent.left) {\n              nodeParent.left = detached;\n            } else {\n              nodeParent.right = detached;\n            }\n          } else {\n            this.#root = detached;\n          }\n          \n          detached.parent = nodeParent;\n        }\n      }\n      \n      LRotation = (node) => {\n        if(node.right) {\n          // console.log('l rotate', node.key);\n          const nodeParent = node.parent;\n          const detached = node.right;\n          node.right = detached.left;\n          detached.left = node;\n          node.parent = detached;\n          \n          if(node.right !== null) {\n            node.right.parent = node;\n          }\n          \n          if(nodeParent !== null) {\n            if(node === nodeParent.left) {\n              nodeParent.left = detached;\n            } else {\n              nodeParent.right = detached;\n            }\n          } else {\n            this.#root = detached;\n          }\n          \n          detached.parent = nodeParent;\n        }\n      }\n\n\n      handleRedUncle(parentNode, uncleNode, grandParentNode) {\n        parentNode.color = COLOR.BLACK;\n        uncleNode.color = COLOR.BLACK;\n        grandParentNode.color = COLOR.RED;\n        this.adjustTreeAfterInsertion(grandParentNode);\n      }\n\n      recolorMidNode(node) {\n        node.color = COLOR.BLACK;\n        node.parent.color = COLOR.RED;\n      }\n\n\n\n\n      removerb(key) {\n        this.removeNode(key);\n      }\n\n      removeNode = (key, node = this.#root) => {\n        if(node === null || node.isNil) return;\n    \n        if(this.compare(key, node.key) === BinarySearchTree.comparison.SMALLER) {\n          this.removeNode(key, node.left);\n        } else if(this.compare(key, node.key) === BinarySearchTree.comparison.BIGGER) {\n          this.removeNode(key, node.right);\n        } else if(node.left.isNil && node.right.isNil) {\n          // console.log('remove 1', node.key)\n          this.handleRemovedNode(node);\n          \n          if(node.parent === null) {\n            this.#root = null;\n          } else if(node === node.parent.left) {\n            node.parent.left = this.createNode(null, node);\n          } else {\n            node.parent.right = this.createNode(null, node);\n          }\n        } else if(node.left.isNil) {\n          // console.log('remove 2', node.key)\n          node.key = node.right.key;\n          node.right = this.createNode(null, node);\n        } else if(node.right.isNil) {\n          // console.log('remove 3', node.key)\n          node.key = node.left.key;\n          node.left = this.createNode(null, node);\n        } else {\n          const max = this.maxNode(node.left);\n          // console.log('remove 4', node.key)\n          node.key = max.key;\n          this.removeNode(max.key, node.left);\n        }\n      }\n      maxNode = (node) => {\n        while(node && !node.isNill && !node.right.isNil) {\n          node = node.right;\n        }\n    \n        return node;\n      }\n\n      getNodeSibling(node) {\n        const parentNode = node.parent;\n        const sibNode = parentNode.left === node\n          ? parentNode.right\n          : parentNode.left;\n        \n        return sibNode;\n      }\n\n      handleCase2(node) {\n        // sibling is red with 2 black children\n        const sibNode = this.getNodeSibling(node);\n    \n        if(sibNode.isRed) {\n          const parentNode = node.parent;\n        \n          sibNode.color = COLOR.BLACK;\n          parentNode.color = COLOR.RED;\n    \n          if(node === parentNode.left) {\n            this.LRotation(parentNode);\n          } else {\n            this.RRotation(parentNode);\n          }\n        }\n        \n        this.handleCase3(node);\n      }\n      \n      handleCase3(node) {\n        // node parent is black, sibling and its children are black\n        const sibNode = this.getNodeSibling(node);\n        \n        if(\n          node.parent.isBlack && \n          sibNode.isBlack && \n          sibNode.left.isBlack && \n          sibNode.right.isBlack\n        ) {\n          sibNode.color = COLOR.RED;\n          this.handleRemovedNode(node.parent);\n        } else {\n          this.handleCase4(node);\n        }\n      }\n      \n      handleCase4(node) {\n        // node parent is red, sibling and its children are black\n        const sibNode = this.getNodeSibling(node);\n        \n        if(\n          node.parent.isRed && \n          sibNode.isBlack && \n          sibNode.left.isBlack && \n          sibNode.right.isBlack\n        ) {\n          sibNode.color = COLOR.RED;\n          node.parent.color = COLOR.BLACK;\n        } else {\n          this.handleCase5(node);\n        }\n      }\n      \n      handleCase5(node) {\n        // sib is black with red left and black right\n        const sibNode = this.getNodeSibling(node);\n        \n        if(sibNode.isBlack) {\n          const parentNode = node.parent;\n        \n          if(node === parentNode.left && sibNode.left.isRed && sibNode.right.isBlack) {\n            sibNode.color = COLOR.RED;\n            sibNode.left.color = COLOR.BLACK;\n            this.RRotation(sibNode);\n          }\n    \n          if(node === parentNode.right && sibNode.left.isBlack && sibNode.right.isRed) {\n            sibNode.color = COLOR.RED;\n            sibNode.right.color = COLOR.BLACK;\n            this.LRotation(sibNode);\n          }\n        }\n       \n        this.handleCase6(node);\n      }\n      \n      handleCase6(node) {\n        // sib is black with red right and black left\n        const sibNode = this.getNodeSibling(node);\n        const parentNode = node.parent;\n          \n        sibNode.color = parentNode.color;\n        parentNode.color = COLOR.BLACK;\n    \n        if(node === parentNode.left) {\n          sibNode.right.color = COLOR.BLACK;\n          this.LRotation(parentNode);\n        } else {\n          sibNode.left.color = COLOR.BLACK;\n          this.RRotation(parentNode);\n        }\n      }\n      \n      handleRemovedNode(node) {\n        // console.log('case 1', node.key);\n        // node is black and with a parent\n        if(node.isBlack && node.parent !== null) {// case 1\n          this.handleCase2(node);\n        }\n      }\n      \n\n  }\nexport default RBTREE;"],"mappings":";;AAAA,OAAOA,gBAAgB,MAAM,8BAA8B;AAC3D,MAAMC,KAAK,GAAGC,MAAM,CAACC,MAAM,CAAC;EACxBC,GAAG,EAAE,KAAK;EACVC,KAAK,EAAE;AACT,CAAC,CAAC;AAAA,IAAAC,MAAA,gBAAAC,0BAAA;AAEF,MAAMC,YAAY,CAAC;EAKjBC,WAAWA,CAACC,GAAG,GAAG,IAAI,EAAEC,MAAM,GAAG,IAAI,EAAE;IAAAT,MAAA,CAAAU,cAAA,OAAAN,MAAA;MAAAO,QAAA;MAAAC,KAAA;IAAA;IAAA,KAFvCC,IAAI,GAAG,IAAI;IAAA,KACXC,KAAK,GAAG,IAAI;IAER,IAAI,CAACN,GAAG,GAAGA,GAAG;IACd,IAAI,CAACC,MAAM,GAAGA,MAAM;IAEpB,IAAGD,GAAG,IAAI,IAAI,EAAE;MACdO,2BAAA,KAAI,EAAAX,MAAA,EAAAA,MAAA,IAAUL,KAAK,CAACI,KAAK;IAC3B,CAAC,MAAM;MACLY,2BAAA,KAAI,EAAAX,MAAA,EAAAA,MAAA,IAAUL,KAAK,CAACG,GAAG;MACvB,IAAI,CAACW,IAAI,GAAG,IAAIP,YAAY,CAAC,IAAI,EAAE,IAAI,CAAC;MACxC,IAAI,CAACQ,KAAK,GAAG,IAAIR,YAAY,CAAC,IAAI,EAAE,IAAI,CAAC;IAC3C;EACF;EACA,IAAIU,KAAKA,CAAA,EAAG;IACV,OAAOD,2BAAA,KAAI,EAAAX,MAAA,EAAAA,MAAA,MAAYL,KAAK,CAACG,GAAG;EAClC;EAEA,IAAIe,OAAOA,CAAA,EAAG;IACZ,OAAO,CAAC,IAAI,CAACD,KAAK;EACpB;EAEA,IAAIE,KAAKA,CAAA,EAAG;IACV,OAAO,IAAI,CAACV,GAAG,KAAK,IAAI;EAC1B;EAEA,IAAIW,KAAKA,CAAA,EAAG;IACV,OAAAJ,2BAAA,CAAO,IAAI,EAAAX,MAAA,EAAAA,MAAA;EACb;EAEA,IAAIe,KAAKA,CAACC,QAAQ,EAAE;IAClB,IAAG,CAAC,IAAI,CAACF,KAAK,EAAE;MACbH,2BAAA,KAAI,EAAAX,MAAA,EAAAA,MAAA,IAAUgB,QAAQ;IACzB;EACF;AAEJ;AAAC,IAAAC,KAAA,gBAAAhB,0BAAA;AAED,MAAMiB,MAAM,SAASxB,gBAAgB;EAInCS,WAAWA,CAACgB,SAAS,GAAG,IAAI,EAAE;IAC5B,IAAIC,EAAE,GAAG,IAAI;IAEb,IAAGD,SAAS,IAAI,OAAOA,SAAS,KAAK,UAAU,EAAE;MAC/CC,EAAE,GAAGD,SAAS;IAChB,CAAC,MAAM;MACLC,EAAE,GAAGA,CAACC,CAAC,EAAEC,CAAC,KAAK;QACb,IAAGD,CAAC,GAAGC,CAAC,EAAE,OAAO5B,gBAAgB,CAAC6B,sBAAsB,CAACC,MAAM;QAC/D,IAAGH,CAAC,GAAGC,CAAC,EAAE,OAAO5B,gBAAgB,CAAC6B,sBAAsB,CAACE,OAAO;QAEhE,OAAO/B,gBAAgB,CAAC6B,sBAAsB,CAACG,KAAK;MACtD,CAAC;IACH;IAEA,KAAK,CAACN,EAAE,CAAC;IAACxB,MAAA,CAAAU,cAAA,OAAAW,KAAA;MAAAV,QAAA;MAAAC,KAAA,EAjBJ;IAAI;IAAA,KA2CVmB,UAAU,GAAG,CAACC,OAAO,EAAEC,WAAW,GAAAlB,2BAAA,CAAG,IAAI,EAAAM,KAAA,EAAAA,KAAA,CAAM,KAAK;MAClD,IAAG,IAAI,CAACa,OAAO,CAACF,OAAO,CAACxB,GAAG,EAAEyB,WAAW,CAACzB,GAAG,CAAC,KAAKV,gBAAgB,CAACqC,UAAU,CAACN,OAAO,EAAE;QACpF,IAAGI,WAAW,CAACpB,IAAI,CAACK,KAAK,EAAE;UACzBe,WAAW,CAACpB,IAAI,GAAGmB,OAAO;UAC1BA,OAAO,CAACvB,MAAM,GAAGwB,WAAW;QAC9B,CAAC,MAAM;UACN,IAAI,CAACF,UAAU,CAACC,OAAO,EAAEC,WAAW,CAACpB,IAAI,CAAC;QAC5C;MACF,CAAC,MAAM;QACJ,IAAGoB,WAAW,CAACnB,KAAK,CAACI,KAAK,EAAE;UAC1Be,WAAW,CAACnB,KAAK,GAAGkB,OAAO;UAC3BA,OAAO,CAACvB,MAAM,GAAGwB,WAAW;QAC9B,CAAC,MAAM;UACL,IAAI,CAACF,UAAU,CAACC,OAAO,EAAEC,WAAW,CAACnB,KAAK,CAAC;QAC7C;MACH;IACF,CAAC;IAAA,KA8CDsB,SAAS,GAAIC,IAAI,IAAK;MACpB,IAAGA,IAAI,CAACxB,IAAI,EAAE;QACZ;QACA,MAAMyB,UAAU,GAAGD,IAAI,CAAC5B,MAAM;QAC9B,MAAM8B,QAAQ,GAAGF,IAAI,CAACxB,IAAI;QAC1BwB,IAAI,CAACxB,IAAI,GAAG0B,QAAQ,CAACzB,KAAK;QAC1ByB,QAAQ,CAACzB,KAAK,GAAGuB,IAAI;QACrBA,IAAI,CAAC5B,MAAM,GAAG8B,QAAQ;QAEtB,IAAGF,IAAI,CAACxB,IAAI,KAAK,IAAI,EAAE;UACrBwB,IAAI,CAACxB,IAAI,CAACJ,MAAM,GAAG4B,IAAI;QACzB;QAEA,IAAGC,UAAU,KAAK,IAAI,EAAE;UACtB,IAAGD,IAAI,KAAKC,UAAU,CAACzB,IAAI,EAAE;YAC3ByB,UAAU,CAACzB,IAAI,GAAG0B,QAAQ;UAC5B,CAAC,MAAM;YACLD,UAAU,CAACxB,KAAK,GAAGyB,QAAQ;UAC7B;QACF,CAAC,MAAM;UACLxB,2BAAA,KAAI,EAAAM,KAAA,EAAAA,KAAA,IAASkB,QAAQ;QACvB;QAEAA,QAAQ,CAAC9B,MAAM,GAAG6B,UAAU;MAC9B;IACF,CAAC;IAAA,KAEDE,SAAS,GAAIH,IAAI,IAAK;MACpB,IAAGA,IAAI,CAACvB,KAAK,EAAE;QACb;QACA,MAAMwB,UAAU,GAAGD,IAAI,CAAC5B,MAAM;QAC9B,MAAM8B,QAAQ,GAAGF,IAAI,CAACvB,KAAK;QAC3BuB,IAAI,CAACvB,KAAK,GAAGyB,QAAQ,CAAC1B,IAAI;QAC1B0B,QAAQ,CAAC1B,IAAI,GAAGwB,IAAI;QACpBA,IAAI,CAAC5B,MAAM,GAAG8B,QAAQ;QAEtB,IAAGF,IAAI,CAACvB,KAAK,KAAK,IAAI,EAAE;UACtBuB,IAAI,CAACvB,KAAK,CAACL,MAAM,GAAG4B,IAAI;QAC1B;QAEA,IAAGC,UAAU,KAAK,IAAI,EAAE;UACtB,IAAGD,IAAI,KAAKC,UAAU,CAACzB,IAAI,EAAE;YAC3ByB,UAAU,CAACzB,IAAI,GAAG0B,QAAQ;UAC5B,CAAC,MAAM;YACLD,UAAU,CAACxB,KAAK,GAAGyB,QAAQ;UAC7B;QACF,CAAC,MAAM;UACLxB,2BAAA,KAAI,EAAAM,KAAA,EAAAA,KAAA,IAASkB,QAAQ;QACvB;QAEAA,QAAQ,CAAC9B,MAAM,GAAG6B,UAAU;MAC9B;IACF,CAAC;IAAA,KAsBDG,UAAU,GAAG,CAACjC,GAAG,EAAE6B,IAAI,GAAAtB,2BAAA,CAAG,IAAI,EAAAM,KAAA,EAAAA,KAAA,CAAM,KAAK;MACvC,IAAGgB,IAAI,KAAK,IAAI,IAAIA,IAAI,CAACnB,KAAK,EAAE;MAEhC,IAAG,IAAI,CAACgB,OAAO,CAAC1B,GAAG,EAAE6B,IAAI,CAAC7B,GAAG,CAAC,KAAKV,gBAAgB,CAACqC,UAAU,CAACN,OAAO,EAAE;QACtE,IAAI,CAACY,UAAU,CAACjC,GAAG,EAAE6B,IAAI,CAACxB,IAAI,CAAC;MACjC,CAAC,MAAM,IAAG,IAAI,CAACqB,OAAO,CAAC1B,GAAG,EAAE6B,IAAI,CAAC7B,GAAG,CAAC,KAAKV,gBAAgB,CAACqC,UAAU,CAACP,MAAM,EAAE;QAC5E,IAAI,CAACa,UAAU,CAACjC,GAAG,EAAE6B,IAAI,CAACvB,KAAK,CAAC;MAClC,CAAC,MAAM,IAAGuB,IAAI,CAACxB,IAAI,CAACK,KAAK,IAAImB,IAAI,CAACvB,KAAK,CAACI,KAAK,EAAE;QAC7C;QACA,IAAI,CAACwB,iBAAiB,CAACL,IAAI,CAAC;QAE5B,IAAGA,IAAI,CAAC5B,MAAM,KAAK,IAAI,EAAE;UACvBM,2BAAA,KAAI,EAAAM,KAAA,EAAAA,KAAA,IAAS,IAAI;QACnB,CAAC,MAAM,IAAGgB,IAAI,KAAKA,IAAI,CAAC5B,MAAM,CAACI,IAAI,EAAE;UACnCwB,IAAI,CAAC5B,MAAM,CAACI,IAAI,GAAG,IAAI,CAAC8B,UAAU,CAAC,IAAI,EAAEN,IAAI,CAAC;QAChD,CAAC,MAAM;UACLA,IAAI,CAAC5B,MAAM,CAACK,KAAK,GAAG,IAAI,CAAC6B,UAAU,CAAC,IAAI,EAAEN,IAAI,CAAC;QACjD;MACF,CAAC,MAAM,IAAGA,IAAI,CAACxB,IAAI,CAACK,KAAK,EAAE;QACzB;QACAmB,IAAI,CAAC7B,GAAG,GAAG6B,IAAI,CAACvB,KAAK,CAACN,GAAG;QACzB6B,IAAI,CAACvB,KAAK,GAAG,IAAI,CAAC6B,UAAU,CAAC,IAAI,EAAEN,IAAI,CAAC;MAC1C,CAAC,MAAM,IAAGA,IAAI,CAACvB,KAAK,CAACI,KAAK,EAAE;QAC1B;QACAmB,IAAI,CAAC7B,GAAG,GAAG6B,IAAI,CAACxB,IAAI,CAACL,GAAG;QACxB6B,IAAI,CAACxB,IAAI,GAAG,IAAI,CAAC8B,UAAU,CAAC,IAAI,EAAEN,IAAI,CAAC;MACzC,CAAC,MAAM;QACL,MAAMO,GAAG,GAAG,IAAI,CAACC,OAAO,CAACR,IAAI,CAACxB,IAAI,CAAC;QACnC;QACAwB,IAAI,CAAC7B,GAAG,GAAGoC,GAAG,CAACpC,GAAG;QAClB,IAAI,CAACiC,UAAU,CAACG,GAAG,CAACpC,GAAG,EAAE6B,IAAI,CAACxB,IAAI,CAAC;MACrC;IACF,CAAC;IAAA,KACDgC,OAAO,GAAIR,IAAI,IAAK;MAClB,OAAMA,IAAI,IAAI,CAACA,IAAI,CAACS,MAAM,IAAI,CAACT,IAAI,CAACvB,KAAK,CAACI,KAAK,EAAE;QAC/CmB,IAAI,GAAGA,IAAI,CAACvB,KAAK;MACnB;MAEA,OAAOuB,IAAI;IACb,CAAC;IAxMD,IAAI,CAACH,OAAO,GAAGV,EAAE;IACjBT,2BAAA,KAAI,EAAAM,KAAA,EAAAA,KAAA,IAAS,IAAI,CAACsB,UAAU,CAAC,IAAI,CAAC;EACpC;EACA,IAAII,IAAIA,CAAA,EAAG;IACP,OAAAhC,2BAAA,CAAO,IAAI,EAAAM,KAAA,EAAAA,KAAA;EACb;EAEAsB,UAAUA,CAACnC,GAAG,GAAG,IAAI,EAAEC,MAAM,GAAG,IAAI,EAAE;IACpC,OAAO,IAAIH,YAAY,CAACE,GAAG,EAAEC,MAAM,CAAC;EACtC;EACAuC,UAAUA,CAAA,EAAG;IACX,OAAO,IAAI,CAACL,UAAU,CAAC,IAAI,CAAC;EAC9B;EAEAM,QAAQA,CAACzC,GAAG,EAAE;IACd,MAAMwB,OAAO,GAAG,IAAI,CAACW,UAAU,CAACnC,GAAG,CAAC;IAEpC,IAAIO,2BAAA,KAAI,EAAAM,KAAA,EAAAA,KAAA,MAAW,IAAI,EAAE;MACzBN,2BAAA,KAAI,EAAAM,KAAA,EAAAA,KAAA,IAAS,IAAI,CAAC2B,UAAU,CAAC,CAAC;IAC9B;IAEA,IAAI,CAACjB,UAAU,CAACC,OAAO,CAAC;IACxB,IAAI,CAACkB,wBAAwB,CAAClB,OAAO,CAAC;EACtC;EAoBAkB,wBAAwBA,CAACb,IAAI,EAAE;IAC7B,IAAGA,IAAI,CAAC5B,MAAM,KAAK,IAAI,EAAE;MACvB4B,IAAI,CAAClB,KAAK,GAAGpB,KAAK,CAACI,KAAK;IAC1B,CAAC,MAAM,IAAGkC,IAAI,CAAC5B,MAAM,CAACO,KAAK,EAAE;MAC3B,MAAMmC,UAAU,GAAGd,IAAI,CAAC5B,MAAM;MAC9B,MAAM2C,eAAe,GAAGD,UAAU,CAAC1C,MAAM;MACzC,MAAM4C,SAAS,GAAGD,eAAe,CAACvC,IAAI,KAAKsC,UAAU,GACjDC,eAAe,CAACtC,KAAK,GACrBsC,eAAe,CAACvC,IAAI;MAExB,IAAGwC,SAAS,CAACpC,OAAO,EAAE;QACpB;QACA,IAAI,CAACqC,gBAAgB,CAACjB,IAAI,CAAC;MAC7B,CAAC,MAAM;QACL;QACA,IAAI,CAACkB,cAAc,CAACJ,UAAU,EAAEE,SAAS,EAAED,eAAe,CAAC;MAC7D;IACF;EACF;EAEAE,gBAAgBA,CAACjB,IAAI,EAAE;IACrB,MAAMc,UAAU,GAAGd,IAAI,CAAC5B,MAAM;IAE9B,IAAG4B,IAAI,KAAKc,UAAU,CAACtC,IAAI,EAAE;MAC3B,IAAGsC,UAAU,KAAKA,UAAU,CAAC1C,MAAM,CAACI,IAAI,EAAE;QACxC,IAAI,CAAC2C,cAAc,CAACL,UAAU,CAAC;QAC/B,IAAI,CAACf,SAAS,CAACe,UAAU,CAAC1C,MAAM,CAAC;MACnC,CAAC,MAAM;QACL,IAAI,CAAC2B,SAAS,CAACe,UAAU,CAAC;QAC1B,IAAI,CAACK,cAAc,CAACnB,IAAI,CAAC;QACzB,IAAI,CAACG,SAAS,CAACH,IAAI,CAAC5B,MAAM,CAAC;MAC7B;IACF,CAAC,MAAM;MACL,IAAG0C,UAAU,KAAKA,UAAU,CAAC1C,MAAM,CAACK,KAAK,EAAE;QACzC,IAAI,CAAC0C,cAAc,CAACL,UAAU,CAAC;QAC/B,IAAI,CAACX,SAAS,CAACW,UAAU,CAAC1C,MAAM,CAAC;MACnC,CAAC,MAAM;QACL,IAAI,CAAC+B,SAAS,CAACW,UAAU,CAAC;QAC1B,IAAI,CAACK,cAAc,CAACnB,IAAI,CAAC;QACzB,IAAI,CAACD,SAAS,CAACC,IAAI,CAAC5B,MAAM,CAAC;MAC7B;IACF;EACF;EAyDA8C,cAAcA,CAACJ,UAAU,EAAEE,SAAS,EAAED,eAAe,EAAE;IACrDD,UAAU,CAAChC,KAAK,GAAGpB,KAAK,CAACI,KAAK;IAC9BkD,SAAS,CAAClC,KAAK,GAAGpB,KAAK,CAACI,KAAK;IAC7BiD,eAAe,CAACjC,KAAK,GAAGpB,KAAK,CAACG,GAAG;IACjC,IAAI,CAACgD,wBAAwB,CAACE,eAAe,CAAC;EAChD;EAEAI,cAAcA,CAACnB,IAAI,EAAE;IACnBA,IAAI,CAAClB,KAAK,GAAGpB,KAAK,CAACI,KAAK;IACxBkC,IAAI,CAAC5B,MAAM,CAACU,KAAK,GAAGpB,KAAK,CAACG,GAAG;EAC/B;EAKAuD,QAAQA,CAACjD,GAAG,EAAE;IACZ,IAAI,CAACiC,UAAU,CAACjC,GAAG,CAAC;EACtB;EA2CAkD,cAAcA,CAACrB,IAAI,EAAE;IACnB,MAAMc,UAAU,GAAGd,IAAI,CAAC5B,MAAM;IAC9B,MAAMkD,OAAO,GAAGR,UAAU,CAACtC,IAAI,KAAKwB,IAAI,GACpCc,UAAU,CAACrC,KAAK,GAChBqC,UAAU,CAACtC,IAAI;IAEnB,OAAO8C,OAAO;EAChB;EAEAC,WAAWA,CAACvB,IAAI,EAAE;IAChB;IACA,MAAMsB,OAAO,GAAG,IAAI,CAACD,cAAc,CAACrB,IAAI,CAAC;IAEzC,IAAGsB,OAAO,CAAC3C,KAAK,EAAE;MAChB,MAAMmC,UAAU,GAAGd,IAAI,CAAC5B,MAAM;MAE9BkD,OAAO,CAACxC,KAAK,GAAGpB,KAAK,CAACI,KAAK;MAC3BgD,UAAU,CAAChC,KAAK,GAAGpB,KAAK,CAACG,GAAG;MAE5B,IAAGmC,IAAI,KAAKc,UAAU,CAACtC,IAAI,EAAE;QAC3B,IAAI,CAAC2B,SAAS,CAACW,UAAU,CAAC;MAC5B,CAAC,MAAM;QACL,IAAI,CAACf,SAAS,CAACe,UAAU,CAAC;MAC5B;IACF;IAEA,IAAI,CAACU,WAAW,CAACxB,IAAI,CAAC;EACxB;EAEAwB,WAAWA,CAACxB,IAAI,EAAE;IAChB;IACA,MAAMsB,OAAO,GAAG,IAAI,CAACD,cAAc,CAACrB,IAAI,CAAC;IAEzC,IACEA,IAAI,CAAC5B,MAAM,CAACQ,OAAO,IACnB0C,OAAO,CAAC1C,OAAO,IACf0C,OAAO,CAAC9C,IAAI,CAACI,OAAO,IACpB0C,OAAO,CAAC7C,KAAK,CAACG,OAAO,EACrB;MACA0C,OAAO,CAACxC,KAAK,GAAGpB,KAAK,CAACG,GAAG;MACzB,IAAI,CAACwC,iBAAiB,CAACL,IAAI,CAAC5B,MAAM,CAAC;IACrC,CAAC,MAAM;MACL,IAAI,CAACqD,WAAW,CAACzB,IAAI,CAAC;IACxB;EACF;EAEAyB,WAAWA,CAACzB,IAAI,EAAE;IAChB;IACA,MAAMsB,OAAO,GAAG,IAAI,CAACD,cAAc,CAACrB,IAAI,CAAC;IAEzC,IACEA,IAAI,CAAC5B,MAAM,CAACO,KAAK,IACjB2C,OAAO,CAAC1C,OAAO,IACf0C,OAAO,CAAC9C,IAAI,CAACI,OAAO,IACpB0C,OAAO,CAAC7C,KAAK,CAACG,OAAO,EACrB;MACA0C,OAAO,CAACxC,KAAK,GAAGpB,KAAK,CAACG,GAAG;MACzBmC,IAAI,CAAC5B,MAAM,CAACU,KAAK,GAAGpB,KAAK,CAACI,KAAK;IACjC,CAAC,MAAM;MACL,IAAI,CAAC4D,WAAW,CAAC1B,IAAI,CAAC;IACxB;EACF;EAEA0B,WAAWA,CAAC1B,IAAI,EAAE;IAChB;IACA,MAAMsB,OAAO,GAAG,IAAI,CAACD,cAAc,CAACrB,IAAI,CAAC;IAEzC,IAAGsB,OAAO,CAAC1C,OAAO,EAAE;MAClB,MAAMkC,UAAU,GAAGd,IAAI,CAAC5B,MAAM;MAE9B,IAAG4B,IAAI,KAAKc,UAAU,CAACtC,IAAI,IAAI8C,OAAO,CAAC9C,IAAI,CAACG,KAAK,IAAI2C,OAAO,CAAC7C,KAAK,CAACG,OAAO,EAAE;QAC1E0C,OAAO,CAACxC,KAAK,GAAGpB,KAAK,CAACG,GAAG;QACzByD,OAAO,CAAC9C,IAAI,CAACM,KAAK,GAAGpB,KAAK,CAACI,KAAK;QAChC,IAAI,CAACiC,SAAS,CAACuB,OAAO,CAAC;MACzB;MAEA,IAAGtB,IAAI,KAAKc,UAAU,CAACrC,KAAK,IAAI6C,OAAO,CAAC9C,IAAI,CAACI,OAAO,IAAI0C,OAAO,CAAC7C,KAAK,CAACE,KAAK,EAAE;QAC3E2C,OAAO,CAACxC,KAAK,GAAGpB,KAAK,CAACG,GAAG;QACzByD,OAAO,CAAC7C,KAAK,CAACK,KAAK,GAAGpB,KAAK,CAACI,KAAK;QACjC,IAAI,CAACqC,SAAS,CAACmB,OAAO,CAAC;MACzB;IACF;IAEA,IAAI,CAACK,WAAW,CAAC3B,IAAI,CAAC;EACxB;EAEA2B,WAAWA,CAAC3B,IAAI,EAAE;IAChB;IACA,MAAMsB,OAAO,GAAG,IAAI,CAACD,cAAc,CAACrB,IAAI,CAAC;IACzC,MAAMc,UAAU,GAAGd,IAAI,CAAC5B,MAAM;IAE9BkD,OAAO,CAACxC,KAAK,GAAGgC,UAAU,CAAChC,KAAK;IAChCgC,UAAU,CAAChC,KAAK,GAAGpB,KAAK,CAACI,KAAK;IAE9B,IAAGkC,IAAI,KAAKc,UAAU,CAACtC,IAAI,EAAE;MAC3B8C,OAAO,CAAC7C,KAAK,CAACK,KAAK,GAAGpB,KAAK,CAACI,KAAK;MACjC,IAAI,CAACqC,SAAS,CAACW,UAAU,CAAC;IAC5B,CAAC,MAAM;MACLQ,OAAO,CAAC9C,IAAI,CAACM,KAAK,GAAGpB,KAAK,CAACI,KAAK;MAChC,IAAI,CAACiC,SAAS,CAACe,UAAU,CAAC;IAC5B;EACF;EAEAT,iBAAiBA,CAACL,IAAI,EAAE;IACtB;IACA;IACA,IAAGA,IAAI,CAACpB,OAAO,IAAIoB,IAAI,CAAC5B,MAAM,KAAK,IAAI,EAAE;MAAC;MACxC,IAAI,CAACmD,WAAW,CAACvB,IAAI,CAAC;IACxB;EACF;AAGJ;AACF,eAAef,MAAM"},"metadata":{},"sourceType":"module","externalDependencies":[]}